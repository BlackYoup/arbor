# Copyright 1999-2006 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo-x86/eclass/eutils.eclass,v 1.280 2007/05/05 07:52:26 vapier Exp $
#
# This eclass is for general purpose functions that most ebuilds
# have to implement themselves.
#
# NB:  If you add anything, please comment it!
#
# Maintainer: see each individual function, base-system@gentoo.org as default

require multilib

# Cheap replacement for when debianutils (and thus mktemp)
# does not exist on the users system
# vapier@gentoo.org
#
# Takes just 1 optional parameter (the directory to create tmpfile in)
emktemp() {
    local exe="touch"
    [[ $1 == -d ]] && exe="mkdir" && shift
    local topdir=$1

    if [[ -z ${topdir} ]] ; then
        [[ -z ${T} ]] \
            && topdir="/tmp" \
            || topdir=${T}
    fi

    if ! type -P mktemp > /dev/null ; then
        # system lacks `mktemp` so we have to fake it
        local tmp=/
        while [[ -e ${tmp} ]] ; do
            tmp=${topdir}/tmp.${RANDOM}.${RANDOM}.${RANDOM}
        done
        ${exe} "${tmp}" || ${exe} -p "${tmp}"
        echo "${tmp}"
    else
        # the args here will give slightly wierd names on BSD,
        # but should produce a usable file on all userlands
        if [[ ${exe} == "touch" ]] ; then
            TMPDIR="${topdir}" mktemp -t tmp.XXXXXXXXXX
        else
            TMPDIR="${topdir}" mktemp -dt tmp.XXXXXXXXXX
        fi
    fi
}

# Small wrapper for getent (Linux), nidump (Mac OS X),
# and pw (FreeBSD) used in enewuser()/enewgroup()
# Joe Jezak <josejx@gmail.com> and usata@gentoo.org
# FBSD stuff: Aaron Walker <ka0ttic@gentoo.org>
#
# egetent(database, key)
egetent() {
    case ${CHOST} in
    *-darwin*)
        case "$2" in
        *[!0-9]*) # Non numeric
            nidump $1 . | awk -F":" "{ if (\$1 ~ /^$2$/) {print \$0;exit;} }"
            ;;
        *)  # Numeric
            nidump $1 . | awk -F":" "{ if (\$3 == $2) {print \$0;exit;} }"
            ;;
        esac
        ;;
    *-freebsd*|*-dragonfly*)
        local opts action="user"
        [[ $1 == "passwd" ]] || action="group"

        # lookup by uid/gid
        if [[ $2 == [[:digit:]]* ]] ; then
            [[ ${action} == "user" ]] && opts="-u" || opts="-g"
        fi

        pw show ${action} ${opts} "$2" -q
        ;;
    *-netbsd*|*-openbsd*)
        grep "$2:\*:" /etc/$1
        ;;
    *)
        type -p nscd >& /dev/null && nscd -i "$1"
        getent "$1" "$2"
        ;;
    esac
}

# Simplify/standardize adding users to the system
# vapier@gentoo.org
#
# enewuser(username, uid, shell, homedir, groups, extra options)
#
# Default values if you do not specify any:
# username: REQUIRED !
# uid:      next available (see useradd(8))
#       note: pass -1 to get default behavior
# shell:    /bin/false
# homedir:  /dev/null
# groups:   none
# extra:    comment of 'autogenerated user for ${PN}'
enewuser() {
    case ${EBUILD_PHASE} in
        unpack|compile|test|install)
        eerror "'enewuser()' called from '${EBUILD_PHASE}()' which is not a pkg_* function."
        eerror "Package fails at QA and at life.  Please file a bug."
        die "Bad package!  enewuser is only for use in pkg_* functions!"
    esac

    # get the username
    local euser=$1; shift
    if [[ -z ${euser} ]] ; then
        eerror "No username specified !"
        die "Cannot call enewuser without a username"
    fi

    # lets see if the username already exists
    if [[ -n $(egetent passwd "${euser}") ]] ; then
        return 0
    fi
    einfo "Adding user '${euser}' to your system ..."

    # options to pass to useradd
    local opts=

    # handle uid
    local euid=$1; shift
    if [[ -n ${euid} && ${euid} != -1 ]] ; then
        if [[ ${euid} -gt 0 ]] ; then
            if [[ -n $(egetent passwd ${euid}) ]] ; then
                euid="next"
            fi
        else
            eerror "Userid given but is not greater than 0 !"
            die "${euid} is not a valid UID"
        fi
    else
        euid="next"
    fi
    if [[ ${euid} == "next" ]] ; then
        for ((euid = 101; euid <= 999; euid++)); do
            [[ -z $(egetent passwd ${euid}) ]] && break
        done
    fi
    opts="${opts} -u ${euid}"
    einfo " - Userid: ${euid}"

    # handle shell
    local eshell=$1; shift
    if [[ ! -z ${eshell} ]] && [[ ${eshell} != "-1" ]] ; then
        if [[ ! -e ${ROOT}${eshell} ]] ; then
            eerror "A shell was specified but it does not exist !"
            die "${eshell} does not exist in ${ROOT}"
        fi
        if [[ ${eshell} == */false || ${eshell} == */nologin ]] ; then
            eerror "Do not specify ${eshell} yourself, use -1"
            die "Pass '-1' as the shell parameter"
        fi
    else
        for shell in /sbin/nologin /usr/sbin/nologin /bin/false /usr/bin/false /dev/null ; do
            [[ -x ${ROOT}${shell} ]] && break
        done

        if [[ ${shell} == "/dev/null" ]] ; then
            eerror "Unable to identify the shell to use, proceeding with userland default."
            case ${USERLAND} in
                GNU) shell="/bin/false" ;;
                BSD) shell="/sbin/nologin" ;;
                Darwin) shell="/usr/sbin/nologin" ;;
                *) die "Unable to identify the default shell for userland ${USERLAND}"
            esac
        fi

        eshell=${shell}
    fi
    einfo " - Shell: ${eshell}"
    opts="${opts} -s ${eshell}"

    # handle homedir
    local ehome=$1; shift
    if [[ -z ${ehome} ]] || [[ ${ehome} == "-1" ]] ; then
        ehome="/dev/null"
    fi
    einfo " - Home: ${ehome}"
    opts="${opts} -d ${ehome}"

    # handle groups
    local egroups=$1; shift
    if [[ ! -z ${egroups} ]] ; then
        local oldifs=${IFS}
        local defgroup="" exgroups=""

        export IFS=","
        for g in ${egroups} ; do
            export IFS=${oldifs}
            if [[ -z $(egetent group "${g}") ]] ; then
                eerror "You must add group ${g} to the system first"
                die "${g} is not a valid GID"
            fi
            if [[ -z ${defgroup} ]] ; then
                defgroup=${g}
            else
                exgroups="${exgroups},${g}"
            fi
            export IFS=","
        done
        export IFS=${oldifs}

        opts="${opts} -g ${defgroup}"
        if [[ ! -z ${exgroups} ]] ; then
            opts="${opts} -G ${exgroups:1}"
        fi
    else
        egroups="(none)"
    fi
    einfo " - Groups: ${egroups}"

    # handle extra and add the user
    local oldsandbox=${SANDBOX_ON}
    export SANDBOX_ON="0"
    case ${CHOST} in
    *-darwin*)
        ### Make the user
        if [[ -z $@ ]] ; then
            dscl . create /users/${euser} uid ${euid}
            dscl . create /users/${euser} shell ${eshell}
            dscl . create /users/${euser} home ${ehome}
            dscl . create /users/${euser} realname "autogenerated user for ${PN}"
            ### Add the user to the groups specified
            local oldifs=${IFS}
            export IFS=","
            for g in ${egroups} ; do
                dscl . merge /groups/${g} users ${euser}
            done
            export IFS=${oldifs}
        else
            einfo "Extra options are not supported on Darwin yet"
            einfo "Please report the ebuild along with the info below"
            einfo "eextra: $@"
            die "Required function missing"
        fi
        ;;
    *-freebsd*|*-dragonfly*)
        if [[ -z $@ ]] ; then
            pw useradd ${euser} ${opts} \
                -c "autogenerated user for ${PN}" \
                die "enewuser failed"
        else
            einfo " - Extra: $@"
            pw useradd ${euser} ${opts} \
                "$@" || die "enewuser failed"
        fi
        ;;

    *-netbsd*)
        if [[ -z $@ ]] ; then
            useradd ${opts} ${euser} || die "enewuser failed"
        else
            einfo " - Extra: $@"
            useradd ${opts} ${euser} "$@" || die "enewuser failed"
        fi
        ;;

    *-openbsd*)
        if [[ -z $@ ]] ; then
            useradd -u ${euid} -s ${eshell} \
                -d ${ehome} -c "autogenerated user for ${PN}" \
                -g ${egroups} ${euser} || die "enewuser failed"
        else
            einfo " - Extra: $@"
            useradd -u ${euid} -s ${eshell} \
                -d ${ehome} -c "autogenerated user for ${PN}" \
                -g ${egroups} ${euser} "$@" || die "enewuser failed"
        fi
        ;;

    *)
        if [[ -z $@ ]] ; then
            useradd ${opts} ${euser} \
                -c "autogenerated user for ${PN}" \
                || die "enewuser failed"
        else
            einfo " - Extra: $@"
            useradd ${opts} ${euser} "$@" \
                || die "enewuser failed"
        fi
        ;;
    esac

    if [[ ! -e ${ROOT}/${ehome} ]] ; then
        einfo " - Creating ${ehome} in ${ROOT}"
        mkdir -p "${ROOT}/${ehome}"
        chown ${euser} "${ROOT}/${ehome}"
        chmod 755 "${ROOT}/${ehome}"
    fi

    export SANDBOX_ON=${oldsandbox}
}

# Simplify/standardize adding groups to the system
# vapier@gentoo.org
#
# enewgroup(group, gid)
#
# Default values if you do not specify any:
# groupname:    REQUIRED !
# gid:      next available (see groupadd(8))
# extra:    none
enewgroup() {
    case ${EBUILD_PHASE} in
        unpack|compile|test|install)
        eerror "'enewgroup()' called from '${EBUILD_PHASE}()' which is not a pkg_* function."
        eerror "Package fails at QA and at life.  Please file a bug."
        die "Bad package!  enewgroup is only for use in pkg_* functions!"
    esac

    # get the group
    local egroup="$1"; shift
    if [ -z "${egroup}" ]
    then
        eerror "No group specified !"
        die "Cannot call enewgroup without a group"
    fi

    # see if group already exists
    if [[ -n $(egetent group "${egroup}") ]]; then
        return 0
    fi
    einfo "Adding group '${egroup}' to your system ..."

    # options to pass to useradd
    local opts=

    # handle gid
    local egid="$1"; shift
    if [ ! -z "${egid}" ]
    then
        if [ "${egid}" -gt 0 ]
        then
            if [ -z "`egetent group ${egid}`" ]
            then
                if [[ "${CHOST}" == *-darwin* ]]; then
                    opts="${opts} ${egid}"
                else
                    opts="${opts} -g ${egid}"
                fi
            else
                egid="next available; requested gid taken"
            fi
        else
            eerror "Groupid given but is not greater than 0 !"
            die "${egid} is not a valid GID"
        fi
    else
        egid="next available"
    fi
    einfo " - Groupid: ${egid}"

    # handle extra
    local eextra="$@"
    opts="${opts} ${eextra}"

    # add the group
    local oldsandbox="${SANDBOX_ON}"
    export SANDBOX_ON="0"
    case ${CHOST} in
    *-darwin*)
        if [ ! -z "${eextra}" ];
        then
            einfo "Extra options are not supported on Darwin/OS X yet"
            einfo "Please report the ebuild along with the info below"
            einfo "eextra: ${eextra}"
            die "Required function missing"
        fi

        # If we need the next available
        case ${egid} in
        *[!0-9]*) # Non numeric
            for ((egid = 101; egid <= 999; egid++)); do
                [[ -z $(egetent group ${egid}) ]] && break
            done
        esac
        dscl . create /groups/${egroup} gid ${egid}
        dscl . create /groups/${egroup} passwd '*'
        ;;

    *-freebsd*|*-dragonfly*)
        case ${egid} in
            *[!0-9]*) # Non numeric
                for ((egid = 101; egid <= 999; egid++)); do
                    [[ -z $(egetent group ${egid}) ]] && break
                done
        esac
        pw groupadd ${egroup} -g ${egid} || die "enewgroup failed"
        ;;

    *-netbsd*)
        case ${egid} in
        *[!0-9]*) # Non numeric
            for ((egid = 101; egid <= 999; egid++)); do
                [[ -z $(egetent group ${egid}) ]] && break
            done
        esac
        groupadd -g ${egid} ${egroup} || die "enewgroup failed"
        ;;

    *)
        groupadd ${opts} ${egroup} || die "enewgroup failed"
        ;;
    esac
    export SANDBOX_ON="${oldsandbox}"
}

# Simple script to replace 'dos2unix' binaries
# vapier@gentoo.org
#
# edos2unix(file, <more files> ...)
edos2unix() {
    echo "$@" | xargs sed -i 's/\r$//'
}

