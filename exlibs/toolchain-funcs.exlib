# Copyright 1999-2007 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo-x86/eclass/toolchain-funcs.eclass,v 1.69 2007/03/27 01:46:50 vapier Exp $
#
# Maintainer: Toolchain Ninjas <toolchain@gentoo.org>
#
# This eclass contains (or should) functions to get common info
# about the toolchain (libc/compiler/binutils/etc...)

___ECLASS_RECUR_TOOLCHAIN_FUNCS="yes"
[[ -z ${___ECLASS_RECUR_MULTILIB} ]] && require multilib

tc-getPROG() {
    local var=$1
    local prog=$2

    if [[ -n ${!var} ]] ; then
        echo "${!var}"
        return 0
    fi

    local search=
    [[ -n $3 ]] && search=$(type -p "$3-${prog}")
    [[ -z ${search} && -n ${CHOST} ]] && search=$(type -p "${CHOST}-${prog}")
    [[ -n ${search} ]] && prog=${search##*/}

    export ${var}=${prog}
    echo "${!var}"
}

# Returns the name of the archiver
tc-getAR() { tc-getPROG AR ar "$@"; }
# Returns the name of the assembler
tc-getAS() { tc-getPROG AS as "$@"; }
# Returns the name of the C compiler
tc-getCC() { tc-getPROG CC gcc "$@"; }
# Returns the name of the C preprocessor
tc-getCPP() { tc-getPROG CPP cpp "$@"; }
# Returns the name of the C++ compiler
tc-getCXX() { tc-getPROG CXX g++ "$@"; }
# Returns the name of the linker
tc-getLD() { tc-getPROG LD ld "$@"; }
# Returns the name of the strip prog
tc-getSTRIP() { tc-getPROG STRIP strip "$@"; }
# Returns the name of the symbol/object thingy
tc-getNM() { tc-getPROG NM nm "$@"; }
# Returns the name of the archiver indexer
tc-getRANLIB() { tc-getPROG RANLIB ranlib "$@"; }
# Returns the name of the fortran 77 compiler
tc-getF77() { tc-getPROG F77 f77 "$@"; }
# Returns the name of the fortran 90 compiler
tc-getF90() { tc-getPROG F90 gfortran "$@"; }
# Returns the name of the fortran compiler
tc-getFORTRAN() { tc-getPROG FORTRAN gfortran "$@"; }
# Returns the name of the java compiler
tc-getGCJ() { tc-getPROG GCJ gcj "$@"; }

# Returns the name of the C compiler for build
tc-getBUILD_CC() {
    illegal_in_global_scope

    local v
    for v in CC_FOR_BUILD BUILD_CC HOSTCC ; do
        if [[ -n ${!v} ]] ; then
            export BUILD_CC=${!v}
            echo "${!v}"
            return 0
        fi
    done

    local search=
    if [[ -n ${CBUILD} ]] ; then
        search=$(type -p ${CBUILD}-gcc)
        search=${search##*/}
    fi
    search=${search:-gcc}

    export BUILD_CC=${search}
    echo "${search}"
}

# Quick way to export a bunch of vars at once
tc-export() {
    illegal_in_global_scope

    local var
    for var in "$@" ; do
        eval tc-get${var} > /dev/null
    done
}

# A simple way to see if we're using a cross-compiler ...
tc-is-cross-compiler() {
    illegal_in_global_scope

    return $([[ ${CBUILD:-${CHOST}} != ${CHOST} ]])
}

# Returns the version as by `$CC -dumpversion`
gcc-fullversion() {
    illegal_in_global_scope

    $(tc-getCC "$@") -dumpversion
}
# Returns the version, but only the <major>.<minor>
gcc-version() {
    illegal_in_global_scope

    gcc-fullversion "$@" | cut -f1,2 -d.
}
# Returns the Major version
gcc-major-version() {
    illegal_in_global_scope

    gcc-version "$@" | cut -f1 -d.
}
# Returns the Minor version
gcc-minor-version() {
    illegal_in_global_scope

    gcc-version "$@" | cut -f2 -d.
}
# Returns the Micro version
gcc-micro-version() {
    illegal_in_global_scope

    gcc-fullversion "$@" | cut -f3 -d. | cut -f1 -d-
}

# Check whether our selected compiler supports visibility
has_visibility() {
    illegal_in_global_scope

    # We need >=sys-devel/gcc-4.1
    [[ $(tc-getBUILD_CC) == *gcc* && $(gcc-major-version)$(gcc-minor-version) -ge 41 ]] || return 1
}

# This function generate linker scripts in /usr/lib for dynamic
# libs in /lib.  This is to fix linking problems when you have
# the .so in /lib, and the .a in /usr/lib.  What happens is that
# in some cases when linking dynamic, the .a in /usr/lib is used
# instead of the .so in /lib due to gcc/libtool tweaking ld's
# library search path.  This cause many builds to fail.
# See bug #4411 for more info.
#
# To use, simply call:
#
#   gen_usr_ldscript libfoo.so
#
# Note that you should in general use the unversioned name of
# the library, as ldconfig should usually update it correctly
# to point to the latest version of the library present.
_tc_gen_usr_ldscript() {
    illegal_in_global_scope

    local lib libdir=$(get_libdir) output_format=""
    # Just make sure it exists
    dodir /usr/${libdir}

    # OUTPUT_FORMAT gives hints to the linker as to what binary format
    # is referenced ... makes multilib saner
    output_format=$($(tc-getCC) ${CFLAGS} ${LDFLAGS} -Wl,--verbose 2>&1 | sed -n 's/^OUTPUT_FORMAT("\([^"]*\)",.*/\1/p')
    [[ -n ${output_format} ]] && output_format="OUTPUT_FORMAT ( ${output_format} )"

    for lib in "$@" ; do
        (
            insinto /usr/${libdir}
            hereins ${lib} <<END_LDSCRIPT
/* GNU ld script
   Since Gentoo has critical dynamic libraries
   in /lib, and the static versions in /usr/lib,
   we need to have a "fake" dynamic lib in /usr/lib,
   otherwise we run into linking problems.

   See bug http://bugs.gentoo.org/4411 for more info.
 */
${output_format}
GROUP ( /${libdir}/${lib} )
END_LDSCRIPT
        )
        fperms a+x "/usr/${libdir}/${lib}"
    done
}

gen_usr_ldscript() { _tc_gen_usr_ldscript "$@" ; }

