# Copyright 1999-2004 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo-x86/eclass/versionator.eclass,v 1.13 2007/04/23 19:35:05 swegener Exp $
#
# Original Author: Ciaran McCreesh <ciaranm@gentoo.org>

# This exlib is obsolete, use ever functions instead

get_all_version_components() {
    die "get_all_version_components sucks, use ever split_all"
}

get_version_components() {
    die "get_version_components sucks, use ever split"
}

get_major_version() {
    die "get_major_version sucks, use ever major"
}

get_version_component_range() {
    die "get_version_component_range sucks, use ever range"
}

get_after_major_version() {
    die "get_after_major_version sucks, use ever remainder"
}

replace_version_separator() {
    die "replace_version_separator sucks, use ever replace"
}

replace_all_version_separators() {
    die "replace_all_version_separator sucks, use ever replace_all"
}

delete_version_separator() {
    die "delete_version_separator sucks, use ever delete"
}

delete_all_version_separators() {
    die "delete_all_version_separator sucks, use ever delete"
}

get_version_component_count() {
    die "get_version_component_count sucks, add it to ever if you need it, or count the number of words returned by ever split"
}

# What is the index of the last version component in $1 (defaults to $PV)?
#     1.0.1   ->  3
#     3.0c-r1     ->  4
#
get_last_version_component_index() {
    local a
    a=( $(ever split "${1:-${PV}}" ) )
    echo $(( ${#a[@]} - 1 ))
}

version_is_at_least() {
    die "version_is_at_least sucks, use ever at_least"
}

version_compare() {
    die "version_compare sucks, use ever at_least"
}

# Returns its parameters sorted, highest version last.
version_sort() {
    local items=( "${@}" )
    __version_sort
    echo "${items[@]}"
}

__version_sort() {
    local begin=${1:-0}
    local count=${2:-${#items[@]}}
    [[ ${count} -le 1 ]] && return
    __version_sort ${begin} $((count/2))
    __version_sort $((begin+count/2)) $((count-count/2))
    local left=( "${items[@]:begin:count/2}" )
    local right=( "${items[@]:begin+count/2:count-count/2}" )
    local -i x i=0 j=0
    for (( x=begin; x<begin+count; ++x )); do
        if (( j>=${#right[@]} )) || { (( i<${#left[@]} )) && ! ever at_least "${right[j]}" "${left[i]}"; }; then
            items[x]=${left[i++]}
        else
            items[x]=${right[j++]}
        fi
    done
}

# First argument is a catogory/pn. The remaining arguments are slots. Sorts the
# slots and outputs " || ( cpn:slot1 cpn:slot2 cpn:slot3 ) " etc, where slot1 is
# highest. If there is only one slot it merely outputs " cpn:slot ".
sorted_any_of_slot_dependencies() {
    local i sorted_slots cpn=${1}
    shift
    (( ${#} > 1 )) && echo -n " || ( "
    sorted_slots=( $(version_sort ${@}) )
    for((i=${#sorted_slots[@]}-1; i>=0; --i)); do
        echo -n " ${cpn}:${sorted_slots[i]} "
    done
    (( ${#} > 1 )) && echo -n ") "
}

