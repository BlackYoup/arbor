# Copyright 1999-2004 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo-x86/eclass/versionator.eclass,v 1.13 2007/04/23 19:35:05 swegener Exp $
#
# Original Author: Ciaran McCreesh <ciaranm@gentoo.org>

# This exlib is obsolete, use ever functions instead

get_all_version_components() {
    die "get_all_version_components sucks, use ever split_all"
}

get_version_components() {
    die "get_version_components sucks, use ever split"
}

get_major_version() {
    die "get_major_version sucks, use ever major"
}

get_version_component_range() {
    die "get_version_component_range sucks, use ever range"
}

get_after_major_version() {
    die "get_after_major_version sucks, use ever remainder"
}

replace_version_separator() {
    die "replace_version_separator sucks, use ever replace"
}

replace_all_version_separators() {
    die "replace_all_version_separator sucks, use ever replace_all"
}

delete_version_separator() {
    die "delete_version_separator sucks, use ever delete"
}

delete_all_version_separators() {
    die "delete_all_version_separator sucks, use ever delete"
}

get_version_component_count() {
    die "get_version_component_count sucks, add it to ever if you need it, or count the number of words returned by ever split"
}

# What is the index of the last version component in $1 (defaults to $PV)?
#     1.0.1   ->  3
#     3.0c-r1     ->  4
#
get_last_version_component_index() {
    local a
    a=( $(ever split "${1:-${PV}}" ) )
    echo $(( ${#a[@]} - 1 ))
}

version_is_at_least() {
    die "version_is_at_least sucks, use ever at_least"
}

version_compare() {
    die "version_compare sucks, use ever at_least"
}

# Returns its parameters sorted, highest version last. We're using a quadratic
# algorithm for simplicity, so don't call it with more than a few dozen items.
version_sort() {
    local left=0 idx lowest_idx tmp items=()
    items=( $@ )
    while (( ${left} < ${#items[@]} )); do
        lowest_idx=${left}
        (( idx = lowest_idx + 1 ))
        while (( ${idx} < ${#items[@]} )); do
            ever at_least "${items[idx]}" "${items[lowest_idx]}" && lowest_idx=${idx}
            (( idx += 1 ))
        done
        tmp=${items[lowest_idx]}
        items[lowest_idx]=${items[left]}
        items[left]=${tmp}
        (( left+=1 ))
    done
    echo ${items[@]}
}

# First argument is a catogory/pn. The remaining arguments are slots. Sorts the
# slots and outputs " || ( cpn:slot1 cpn:slot2 cpn:slot3 ) " etc, where slot1 is
# highest. If there is only one slot it merely outputs " cpn:slot ".
sorted_any_of_slot_dependencies() {
    local i sorted_slots cpn=${1}
    shift
    (( ${#} > 1 )) && echo -n " || ( "
    sorted_slots=( $(version_sort ${@}) )
    for((i=${#sorted_slots[@]}-1; i>=0; --i)); do
        echo -n " ${cpn}:${sorted_slots[i]} "
    done
    (( ${#} > 1 )) && echo -n ") "
}

