# Copyright 2008 Bo Ã˜rsted Andresen <zlin@exherbo.org>
# Distributed under the terms of the GNU General Public License v2

export_exlib_phases pkg_pretend

# Print expanded suboptions
# Usage: option_expand ${prefix} ${options}
# Example: linguas da de en -> linguas:da linguas:de linguas:en
option_expand() {
    local prefix=${1} option
    shift
    for option in "${@}"; do
        echo " ${prefix}:${option}"
    done
}

# Check option dependencies.
# Usage: option_check_dependencies ${opt} ${of} ${message} ${dependencies}
check_option_dependencies() {
    local d count=0 opt=${1} of=${2} message=${3}
    # sanity checks
    (( $# > 3 )) || return 0
    case ${of} in
        all|any|"exactly one"|"at most one"|none) :  ;;
        *) die "of='${of}' unsupported by ${FUNCNAME}" ;;
    esac
    shift 3
    # check if opt is enabled (if present)
    if [[ -n ${opt} ]] && option ${opt} || [[ -z ${opt} ]]; then
        # check flags
        for d in "${@}"; do
            if option "${d}"; then
                ((count++))
                case ${of} in
                    any|none)
                        break
                        ;;
                    "exactly one"|"at most one")
                        ((count>1)) && break
                        ;;
                esac
            else
                if [[ ${of} == all ]]; then
                    ((count=-1))
                    break
                fi
            fi
        done
        # return if conditions were met
        case ${of} in
            all|any)       ((count>0))  && return 0 ;;
            none)          ((count==0)) && return 0 ;;
            "exactly one") ((count==1)) && return 0 ;;
            "at most one") ((count<2))  && return 0 ;;
        esac
        # print eerror and increase return value otherwise
        if [[ -n ${message} ]]; then
            eerror "${message}"
        else
            if [[ -n ${opt} ]]; then
                [[ ${opt:0:1} == ! ]] && enabled=disabled || enabled=enabled
                message="When '${opt#!}' is ${enabled}, "
            else
                case ${of:0:1} in
                    a) of="A${of:1}" ;;
                    e) of="E${of:1}" ;;
                    n) of="N${of:1}" ;;
                esac
            fi
            eerror "${message}${of} of the following options must be enabled: '${*}'"
            for d in "${@}"; do
                [[ ${d:0:1} == ! ]] && eerror "Options prefixed with '!' must be disabled rather than enabled to match"
            done
        fi
        return 1
    fi
}

option_dependencies() {
    local opt dep nested=false of=unset m=false message ret=0
    while [[ -n ${@} ]]; do
        # if 'message:' was detected inside a block add everything till the end of the block to message
        if ${m}; then
            while [[ ${1} != ")" ]]; do
                message+=" ${1}"
                shift
            done
            message="${message# }"
            m=false
        fi

        # parse option dependencies and run check_option_dependencies at the end of each block
        case ${1} in
            *"?")
                ${nested} && die "error parsing OPTION_DEPENDENCIES at '${1}', nested option dependencies are not supported"
                opt=${1%?}
                [[ -n ${opt#!} ]] || die "error parsing OPTION_DEPENDENCIES at '${1}'"
                if [[ ${opt#!} == *:* ]]; then
                    has ${opt#*:} ${MYOPTIONS} || die "OPTION_DEPENDENCIES contains '${1}' but ${opt#*:} is not in MYOPTIONS"
                else
                    has ${opt#!} ${MYOPTIONS} || die "OPTION_DEPENDENCIES contains '${1}' but ${opt#!} is not in MYOPTIONS"
                fi
                ;;
            "(")
                ${nested} && die "error parsing OPTION_DEPENDENCIES at '${1}', nested blocks are not supported"
                nested=true
                ;;
            all-of:|any-of:|exactly-one-of:|at-most-one-of:|none-of:)
                ${nested} || die "'${1}' is only valid inside blocks at the beginning"
                [[ ${of} == unset ]] || die "'*-of:' must be specified at most once at the beginning of each block, second '${1}' detected"
                of=${1%-of:}
                of=${of//-/ }
                ;;
            message:)
                ${nested} || die "'${1}' is only valid inside blocks at the end"
                m=true
                [[ ${of} == unset ]] && of=all
                ;;
            ")")
                ${nested} || die "error parsing OPTION_DEPENDENCIES at '${1}', no matching '('"
                check_option_dependencies "${opt}" "${of}" "${message}" ${dep} || ((ret++))
                opt=""
                nested=false
                of=unset
                dep=""
                m=false
                message=""
                ;;
            *)
                ${nested} || die "error parsing OPTION_DEPENDENCIES at '${1}', options are only valid inside blocks"
                [[ -n ${1#!} ]] || die "error parsing OPTION_DEPENDENCIES at '${1}'"
                if [[ ${1#!} == *:* ]]; then
                    has ${1#*:} ${MYOPTIONS} || die "OPTION_DEPENDENCIES contains '${1}' but ${1#*:} is not in MYOPTIONS"
                else
                    has ${1#!} ${MYOPTIONS} || die "OPTION_DEPENDENCIES contains '${1}' but ${1#!} is not in MYOPTIONS"
                fi
                dep+=" ${1}"
                [[ ${of} == unset ]] && of=all
                ;;
        esac

        shift
    done
    ${nested} && die "error parsing OPTION_DEPENDENCIES, '(' has no matching ')'"

    ((ret==0)) || die "Incompatible option combination detected"
}

# Example input:
# OPTION_DEPENDENCIES="
#     ( any-of: a b c )
#     ( at-most-one-of: d e )
#     f? ( exactly-one-of: g h i )
#     !j? ( k !l m )
#     n? ( none-of: o p )
#     !q? ( r message: when q is disabled r must be enabled because otherwise it sucks )
#"
# Conditions only allowed in front of a block.
# No nested blocks.
# Labels only allowed once at the beginning of a block (except for 'message:' which must be at the end and reads the rest of the block)
# Supported labels: all-of (default), any-of, exactly-one-of, at-most-one-of, none-of
options_pkg_pretend() {
    if [[ -n ${OPTION_DEPENDENCIES[@]} ]]; then
        option_dependencies ${OPTION_DEPENDENCIES[@]}
    fi
}
