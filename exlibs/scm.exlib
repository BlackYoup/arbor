# Copyright 2008 David Leverton <dleverton@exherbo.org>
# Distributed under the terms of the GNU General Public License v2
# Based in part upon subversion.eclass, which is:
#    Copyright 1999-2008 Gentoo Foundation

scm_for_each() {
    local SCM_THIS
    for SCM_THIS in "" ${SCM_SECONDARY_REPOSITORIES}; do
        "${@}"
    done
}

scm_var_name() {
    echo SCM${SCM_THIS:+_${SCM_THIS}}_${1}
}

scm_get_var() {
    local var=$(scm_var_name ${1})
    echo "${!var}"
}

scm_set_var() {
    eval "$(scm_var_name ${1})=\${2}"
}

scm_call() {
    local func=${1} type=$(scm_get_var TYPE)
    shift
    if [[ -n $(declare -F scm-${type}_do_${func}) ]]; then
        scm-${type}_do_${func} "${@}"
    elif [[ -n $(declare -F scm_do_${func}) ]]; then
        scm_do_${func} "${@}"
    else
        die "bug in scm-${type}.exlib: scm-${type}_do_${func} not defined"
    fi
}

scm_fetch_one() {
    local dir="$(scm_get_var CHECKOUT_TO)"
    local lock=${dir%/*}/.lock-${dir##*/}

    (
        addwrite "${dir%/*}"
        mkdir -p "${dir%/*}" || die "mkdir failed"
    )

    local SANDBOX_WRITE=${SANDBOX_WRITE}
    addwrite "${dir}"
    addwrite "${lock}"

    {
        flock -x 42 || die "flock failed"

        local whynot status
        if [[ -d ${dir} ]]; then
            whynot="$(scm_call appraise)"
            status=${?}
            [[ ${status} -eq 2 ]] && return
        else
            whynot="${dir} does not exist"
            status=1
        fi

        if [[ -n ${SCM_OFFLINE} ]]; then
            [[ ${status} -eq 1 ]] && die "can't use SCM_OFFLINE because ${whynot}"
            einfo "Not fetching because SCM_OFFLINE is set"
            return
        fi

        if [[ -n ${SCM_MIN_UPDATE_DELAY} ]]; then
            [[ ${SCM_MIN_UPDATE_DELAY} == *[^0123456789]* || ${SCM_MIN_UPDATE_DELAY} -eq 0 ]] \
                && die "SCM_MIN_UPDATE_DELAY must be a positive integer"
            if [[ -e "${dir}/.scm.exlib.timestamp" &&
                    -n "$(find "${dir}" -maxdepth 1 -name .scm.exlib.timestamp \
                              -mmin -$((${SCM_MIN_UPDATE_DELAY} * 60)) -print)" ]]; then
                if [[ ${status} -ne 1 ]]; then
                    einfo "Not fetching because SCM_MIN_UPDATE_DELAY (${SCM_MIN_UPDATE_DELAY}) hours have not passed"
                    return
                else
                    einfo "Ignoring SCM_MIN_UPDATE_DELAY because ${whynot}"
                fi
            fi
        fi

        if [[ -d ${dir} ]]; then
            scm_call update
        else
            scm_call checkout
        fi

        if [[ -d ${dir} ]]; then
            whynot="$(scm_call appraise)"
            [[ ${?} -eq 1 ]] && die "${whynot}"
        else
            die "${dir} does not exist"
        fi

        touch "${dir}/.scm.exlib.timestamp" || die "touch failed"
    } 42>"${lock}" || die "opening lock file failed"
}

scm_src_fetch_extra() {
    scm_for_each scm_fetch_one
}

scm_unpack_one() {
    local dir="$(scm_get_var CHECKOUT_TO)"
    local lock=${dir%/*}/.lock-${dir##*/}

    local SANDBOX_WRITE=${SANDBOX_WRITE}
    addwrite "${dir}"
    addwrite "${lock}"

    {
        flock -s 42 || die "flock failed"

        local whynot
        if [[ -d ${dir} ]]; then
            whynot="$(scm_call appraise)"
            [[ ${?} -eq 1 ]] && die "${whynot}"
        else
            die "${dir} does not exist"
        fi

        scm_call unpack
        rm -f "$(scm_get_var "${1}" UNPACK_TO)/.scm.exlib.timestamp"
    } 42>"${lock}" || die "opening lock file failed"
}

scm_src_unpack() {
    scm_src_fetch_extra

    scm_for_each scm_unpack_one
    SCM_IS_BUILT=1
}

scm_scminfo_one() {
    local rev=$(scm_call revision)
    [[ -n ${rev} ]] || die "could not determine revision for ${SCM_THIS:-primary repository}"
    SCM_INFO+=",${SCM_THIS}=${rev}"
}

scm_pkg_scm_info() {
    local SCM_INFO=""
    scm_for_each scm_scminfo_one
    echo ${SCM_INFO#,=}
}

SCM_IS_BUILT=
scm_pkg_info() {
    if [[ -n ${SCM_IS_BUILT} ]]; then
        local -i SCM_DEFAULT_INFO_COUNT
        local -a secondaries=( ${SCM_SECONDARY_REPOSITORIES} )
        scm_for_each scm_call info
        (( ${SCM_DEFAULT_INFO_COUNT} - 1 == ${#secondaries[@]} )) && default
    else
        default
    fi
}

scm_do_info() {
    SCM_DEFAULT_INFO_COUNT+=1
}

scm_global_stuff() {
    [[ -z $(scm_get_var TYPE) ]] && die "$(scm_var_name TYPE) must be set"
    has scm-$(scm_get_var) ${INHERITED} || require scm-$(scm_get_var TYPE)

    [[ -z $(scm_get_var REPOSITORY) ]] \
        && die "$(scm_var_name REPOSITORY) must be set"
    if ! [[ ${PN} == paludis && -z ${WORKDIR} ]]; then # HACK
        [[ -z $(scm_get_var UNPACK_TO) ]] && scm_set_var UNPACK_TO "${WORKDIR}/${SCM_THIS:-${P}}"
    fi
    local checkout_to="$(scm_get_var CHECKOUT_TO)"
    [[ -z ${checkout_to} ]] && checkout_to="${FETCHEDDIR}/scm/${SCM_THIS:-${PN}}"
    scm_set_var CHECKOUT_TO "${checkout_to%%*(/)}"
    scm_call check_vars

    DEPENDENCIES+=" $(scm_call dependencies)"
}

scm_do_check_vars() {
    :
}

DEPENDENCIES="build,host: >=sys-apps/util-linux-ng-2.13_pre2"
scm_for_each scm_global_stuff

if [[ ${PN} == paludis ]]; then # HACK
    export_exlib_phases src_unpack
else
    #export_exlib_phases src_fetch_extra src_unpack pkg_scm_info pkg_info
    export_exlib_phases src_unpack pkg_info
fi

