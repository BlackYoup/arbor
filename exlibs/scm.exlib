# Copyright 2008 David Leverton <dleverton@exherbo.org>
# Distributed under the terms of the GNU General Public License v2
# Based in part upon subversion.eclass, which is:
#    Copyright 1999-2008 Gentoo Foundation

scm_for_each() {
    [[ ${#} -ge 1 ]] || die "scm_for_each needs at least one argument"
    local SCM_THIS
    for SCM_THIS in "" ${SCM_SECONDARY_REPOSITORIES}; do
        "${@}"
    done
}

scm_var_name() {
    [[ ${#} -eq 1 ]] || die "scm_var_name needs exactly one argument"
    echo SCM${SCM_THIS:+_${SCM_THIS}}_${1}
}

scm_get_var() {
    [[ ${#} -eq 1 ]] || die "scm_get_var needs exactly one argument"
    local var=$(scm_var_name ${1})
    echo "${!var}"
}

scm_set_var() {
    [[ ${#} -eq 2 ]] || die "scm_set_var needs exactly two arguments"
    eval "$(scm_var_name ${1})=\${2}"
}

scm_call() {
    [[ ${#} -ge 1 ]] || die "scm_call needs at least one argument"
    local func=${1} type=$(scm_get_var TYPE)
    shift
    if [[ -n $(declare -F scm-${type}_do_${func}) ]]; then
        scm-${type}_do_${func} "${@}"
    elif [[ -n $(declare -F scm_do_${func}) ]]; then
        scm_do_${func} "${@}"
    else
        die "bug in scm-${type}.exlib: scm-${type}_do_${func} not defined"
    fi
}

scm_access_checkout() {
    [[ ${#} -ge 1 ]] || die "scm_access_checkout needs at least one argument"
    local dir=$(scm_get_var CHECKOUT_TO)
    local lock=${dir%/*}/.lock-${dir##*/}

    (
        addwrite "${FETCHEDDIR}/scm"
        mkdir -p "${dir%/*}"
    ) || die "mkdir failed"

    local SANDBOX_WRITE=${SANDBOX_WRITE}
    addwrite "${dir}"
    addwrite "${lock}"

    {
        flock -x 42 || die "flock failed"
        "${@}"
        local status=${?}
        :
    } 42>"${lock}" || die "opening lock file failed"

    return ${status}
}

scm_fetch_one() {
    local dir=$(scm_get_var CHECKOUT_TO)

    local whynot status
    if [[ -d ${dir} ]]; then
        whynot=$(scm_call appraise)
        status=${?}
        if [[ ${status} -eq 2 ]]; then
            einfo "Not fetching ${SCM_THIS:-primary repository} because the existing checkout is perfect"
            return
        fi
    else
        whynot="${dir} does not exist"
        status=1
    fi

    if [[ -n ${SCM_OFFLINE} ]]; then
        [[ ${status} -ne 0 ]] && die "can't use SCM_OFFLINE for ${SCM_THIS:-primary repository} because ${whynot}"
        einfo "Not fetching ${SCM_THIS:-primary repository} because SCM_OFFLINE is set"
        return
    fi

    if [[ -n ${SCM_MIN_UPDATE_DELAY} ]]; then
        [[ ${SCM_MIN_UPDATE_DELAY} == *[^[:digit:]]* || ${SCM_MIN_UPDATE_DELAY} -eq 0 ]] \
            && die "SCM_MIN_UPDATE_DELAY must be a positive integer"
        if [[ -e ${dir}/.scm.exlib.timestamp &&
                -n $(find "${dir}" -maxdepth 1 -name .scm.exlib.timestamp \
                          -mmin -$((${SCM_MIN_UPDATE_DELAY} * 60)) -print) ]]; then
            if [[ ${status} -eq 0 ]]; then
                einfo "Not fetching ${SCM_THIS:-primary repository} because SCM_MIN_UPDATE_DELAY (${SCM_MIN_UPDATE_DELAY}) hours have not passed"
                return
            else
                einfo "Ignoring SCM_MIN_UPDATE_DELAY for ${SCM_THIS:-primary repository} because ${whynot}"
            fi
        fi
    fi

    if [[ ${status} -eq 3 ]]; then
        echo rm -rf "${dir}"
        rm -rf "${dir}"
        [[ -d ${dir} ]] && die "rm failed"
    fi

    if [[ -d ${dir} ]]; then
        scm_call update
    else
        scm_call checkout
    fi

    if [[ -d ${dir} ]]; then
        whynot=$(scm_call appraise)
        [[ ${?} -eq 1 || ${?} -eq 3 ]] && die "${whynot}"
    else
        die "${dir} does not exist"
    fi

    touch "${dir}/.scm.exlib.timestamp" || die "touch failed"
}

scm_src_fetch_extra() {
    scm_for_each scm_access_checkout scm_fetch_one
}

scm_scminfo_one() {
    local rev=$(scm_call revision)
    [[ -n ${rev} ]] || die "could not determine revision for ${SCM_THIS:-primary repository}"
    SCM_INFO+=,${SCM_THIS}=${rev}
}

scm_pkg_scm_info() {
    local SCM_INFO=
    scm_for_each scm_access_checkout scm_scminfo_one
    echo ${SCM_INFO#,=}
}

scm_unpack_one() {
    local dir=$(scm_get_var CHECKOUT_TO)

    local whynot
    if [[ -d ${dir} ]]; then
        whynot=$(scm_call appraise)
        [[ ${?} -eq 1 || ${?} -eq 3 ]] && die "${whynot}"
    else
        die "${dir} does not exist"
    fi

    scm_call unpack
    rm -f "$(scm_get_var UNPACK_TO)/.scm.exlib.timestamp"

    local rev=$(scm_call revision)
    [[ -n ${rev} ]] || die "could not determine revision for ${SCM_THIS:-primary repository}"
    scm_set_var ACTUAL_REVISION "${rev}"
}

scm_src_unpack() {
    scm_src_fetch_extra

    scm_for_each scm_access_checkout scm_unpack_one
    SCM_IS_BUILT=1
}

SCM_IS_BUILT=
scm_pkg_info() {
    if [[ -n ${SCM_IS_BUILT} ]]; then
        local -i SCM_DEFAULT_INFO_COUNT
        local -a secondaries=( ${SCM_SECONDARY_REPOSITORIES} )
        scm_for_each scm_call info
        (( ${SCM_DEFAULT_INFO_COUNT} - 1 == ${#secondaries[@]} )) && default
    else
        default
    fi
}

scm_do_info() {
    SCM_DEFAULT_INFO_COUNT+=1
}

scm_global_stuff() {
    [[ -z $(scm_get_var TYPE) ]] && die "$(scm_var_name TYPE) must be set"
    has scm-$(scm_get_var TYPE) ${INHERITED} || require scm-$(scm_get_var TYPE)

    [[ -z $(scm_get_var REPOSITORY) ]] \
        && die "$(scm_var_name REPOSITORY) must be set"
    [[ -z $(scm_get_var UNPACK_TO) ]] && scm_set_var UNPACK_TO "${WORKBASE}/${SCM_THIS:-${PNV}}"
    local checkout_to=$(scm_get_var CHECKOUT_TO)
    [[ -z ${checkout_to} ]] && checkout_to=${SCM_THIS:-${PN}}
    [[ ${checkout_to} == /* ]] || checkout_to=${FETCHEDDIR}/scm/${checkout_to}
    scm_set_var CHECKOUT_TO "${checkout_to%%*(/)}"
    scm_call check_vars

    DEPENDENCIES+=" $(scm_call dependencies)"
}

scm_do_check_vars() {
    :
}

DEPENDENCIES="build,host: >=sys-apps/util-linux-ng-2.13_pre2"
scm_for_each scm_global_stuff

#export_exlib_phases src_fetch_extra pkg_scm_info src_unpack pkg_info
export_exlib_phases src_unpack pkg_info

