Source: http://gcc.gnu.org/bugzilla/attachment.cgi?id=25901
Upstream: Yes, http://gcc.gnu.org/bugzilla/show_bug.cgi?id=50888
Reason: Don't include ctype.h for isspace(). Define (c_isspace) and use it
    instead, as otherwise linker will fail at:
    ./.libs/libgcj.so: undefined reference to `__cxa_call_unexpected'
--- libjava/prims.cc.jj	2009-05-04 16:46:48.000000000 +0200
+++ libjava/prims.cc	2011-11-23 13:56:34.067198033 +0100
@@ -38,7 +38,6 @@ details.  */
 #endif
 
 #ifndef DISABLE_GETENV_PROPERTIES
-#include <ctype.h>
 #include <java-props.h>
 #define PROCESS_GCJ_PROPERTIES process_gcj_properties()
 #else
@@ -985,6 +984,8 @@ static java::lang::Thread *main_thread;
 
 #ifndef DISABLE_GETENV_PROPERTIES
 
+#define c_isspace(c) (memchr (" \t\n\r\v\f", c, 6) != NULL)
+
 static char *
 next_property_key (char *s, size_t *length)
 {
@@ -993,7 +994,7 @@ next_property_key (char *s, size_t *leng
   JvAssert (s);
 
   // Skip over whitespace
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   // If we've reached the end, return NULL.  Also return NULL if for
@@ -1005,7 +1006,7 @@ next_property_key (char *s, size_t *leng
 
   // Determine the length of the property key.
   while (s[l] != 0
-	 && ! isspace (s[l])
+	 && ! c_isspace (s[l])
 	 && s[l] != ':'
 	 && s[l] != '=')
     {
@@ -1027,19 +1028,19 @@ next_property_value (char *s, size_t *le
 
   JvAssert (s);
 
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   if (*s == ':'
       || *s == '=')
     s++;
 
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   // Determine the length of the property value.
   while (s[l] != 0
-	 && ! isspace (s[l])
+	 && ! c_isspace (s[l])
 	 && s[l] != ':'
 	 && s[l] != '=')
     {
