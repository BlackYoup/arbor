From e5d1ea319e04039a041a128ab3ab108ba990fc4a Mon Sep 17 00:00:00 2001
From: jakub <jakub@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Wed, 10 Feb 2016 15:06:20 +0000
Subject: [PATCH] 	PR ipa/69241 	PR c++/69649 	* gimplify.c
 (gimplify_modify_expr): Set lhs even for noreturn 	calls if the return
 type is TREE_ADDRESSABLE. 	* cgraphunit.c (cgraph_node::expand_thunk):
 Likewise. 	* ipa-split.c (split_function): Fix doubled "we" in comment. 
 Use void return type for the split part even if 
 !split_point->split_part_set_retval.

	* g++.dg/ipa/pr69241-1.C: New test.
	* g++.dg/ipa/pr69241-2.C: New test.
	* g++.dg/ipa/pr69241-3.C: New test.
	* g++.dg/ipa/pr69649.C: New test.


git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@233271 138bc75d-0d04-0410-961f-82ee72b054a4
---
 gcc/ChangeLog                        | 12 ++++++++++++
 gcc/cgraphunit.c                     |  5 +++--
 gcc/gimplify.c                       |  3 ++-
 gcc/ipa-split.c                      |  7 ++++---
 gcc/testsuite/ChangeLog              | 10 ++++++++++
 gcc/testsuite/g++.dg/ipa/pr69241-1.C | 12 ++++++++++++
 gcc/testsuite/g++.dg/ipa/pr69241-2.C | 18 ++++++++++++++++++
 gcc/testsuite/g++.dg/ipa/pr69241-3.C | 12 ++++++++++++
 gcc/testsuite/g++.dg/ipa/pr69649.C   | 36 ++++++++++++++++++++++++++++++++++++
 9 files changed, 109 insertions(+), 6 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/ipa/pr69241-1.C
 create mode 100644 gcc/testsuite/g++.dg/ipa/pr69241-2.C
 create mode 100644 gcc/testsuite/g++.dg/ipa/pr69241-3.C
 create mode 100644 gcc/testsuite/g++.dg/ipa/pr69649.C

diff --git a/gcc/cgraphunit.c b/gcc/cgraphunit.c
index 2c49d7b..0a745f0 100644
--- a/gcc/cgraphunit.c
+++ b/gcc/cgraphunit.c
@@ -1701,7 +1701,8 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)
       bsi = gsi_start_bb (bb);
 
       /* Build call to the function being thunked.  */
-      if (!VOID_TYPE_P (restype) && !alias_is_noreturn)
+      if (!VOID_TYPE_P (restype)
+	  && (!alias_is_noreturn || TREE_ADDRESSABLE (restype)))
 	{
 	  if (DECL_BY_REFERENCE (resdecl))
 	    {
@@ -1768,7 +1769,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)
 	      || DECL_BY_REFERENCE (resdecl)))
         gimple_call_set_return_slot_opt (call, true);
 
-      if (restmp && !alias_is_noreturn)
+      if (restmp)
 	{
           gimple_call_set_lhs (call, restmp);
 	  gcc_assert (useless_type_conversion_p (TREE_TYPE (restmp),
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index b0ee27e..6aa9db2 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -4828,7 +4828,8 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,
 	    }
 	}
       notice_special_calls (call_stmt);
-      if (!gimple_call_noreturn_p (call_stmt))
+      if (!gimple_call_noreturn_p (call_stmt)
+	  || TREE_ADDRESSABLE (TREE_TYPE (*to_p)))
 	gimple_call_set_lhs (call_stmt, *to_p);
       assign = call_stmt;
     }
diff --git a/gcc/ipa-split.c b/gcc/ipa-split.c
index 929119a..21fd46f 100644
--- a/gcc/ipa-split.c
+++ b/gcc/ipa-split.c
@@ -1254,7 +1254,7 @@ split_function (basic_block return_bb, struct split_point *split_point,
       else
 	main_part_return_p = true;
     }
-  /* The main part also returns if we we split on a fallthru edge
+  /* The main part also returns if we split on a fallthru edge
      and the split part returns.  */
   if (split_part_return_p)
     FOR_EACH_EDGE (e, ei, split_point->entry_bb->preds)
@@ -1364,8 +1364,9 @@ split_function (basic_block return_bb, struct split_point *split_point,
   /* Now create the actual clone.  */
   cgraph_edge::rebuild_edges ();
   node = cur_node->create_version_clone_with_body
-    (vNULL, NULL, args_to_skip, !split_part_return_p, split_point->split_bbs,
-     split_point->entry_bb, "part");
+    (vNULL, NULL, args_to_skip,
+     !split_part_return_p || !split_point->split_part_set_retval,
+     split_point->split_bbs, split_point->entry_bb, "part");
 
   node->split_part = true;
 
diff --git a/gcc/testsuite/g++.dg/ipa/pr69241-1.C b/gcc/testsuite/g++.dg/ipa/pr69241-1.C
new file mode 100644
index 0000000..3e0502a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr69241-1.C
@@ -0,0 +1,12 @@
+// PR ipa/69241
+// { dg-do compile }
+// { dg-options "-O2" }
+
+struct R { R (const R &) {} };
+__attribute__ ((noreturn)) R bar ();
+
+R
+foo ()
+{
+  bar ();
+}
diff --git a/gcc/testsuite/g++.dg/ipa/pr69241-2.C b/gcc/testsuite/g++.dg/ipa/pr69241-2.C
new file mode 100644
index 0000000..bc79bbc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr69241-2.C
@@ -0,0 +1,18 @@
+// PR ipa/69241
+// { dg-do compile }
+// { dg-options "-O2" }
+
+__attribute__((noreturn)) void foo (int);
+struct R { R (const R &) {} };
+
+R
+bar ()
+{
+  foo (0);
+}
+
+R
+baz ()
+{
+  foo (0);
+}
diff --git a/gcc/testsuite/g++.dg/ipa/pr69241-3.C b/gcc/testsuite/g++.dg/ipa/pr69241-3.C
new file mode 100644
index 0000000..3894dc3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr69241-3.C
@@ -0,0 +1,12 @@
+// PR ipa/69241
+// { dg-do compile }
+// { dg-options "-O2" }
+
+struct R { int x[100]; };
+__attribute__ ((noreturn)) R bar ();
+
+void
+foo ()
+{
+  bar ();
+}
diff --git a/gcc/testsuite/g++.dg/ipa/pr69649.C b/gcc/testsuite/g++.dg/ipa/pr69649.C
new file mode 100644
index 0000000..1ad70dc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr69649.C
@@ -0,0 +1,36 @@
+// PR c++/69649
+// { dg-do compile }
+// { dg-options "-O2" }
+
+struct A { virtual void m1 (); };
+struct C : A { void m1 () { m1 (); } };
+template <class T> struct B
+{
+  T *t;
+  B (T *x) : t (x) { if (t) t->m1 (); }
+  B (const B &);
+};
+struct D : public C {};
+struct F : public D
+{
+  virtual B<D> m2 ();
+  virtual B<D> m3 ();
+  int m4 ();
+};
+struct G : F
+{
+  B<D> m2 ();
+  B<D> m3 ();
+};
+B<D> G::m2 ()
+{
+  if (m4 () == 0)
+    return this;
+  return 0;
+}
+B<D> G::m3 ()
+{
+  if (m4 () == 0)
+    return this;
+  return 0;
+}
-- 
2.7.0

