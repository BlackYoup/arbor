From ce2fb8957f75ce4bfee07615f3be7fa76074ef7a Mon Sep 17 00:00:00 2001
From: Saleem Abdulrasool <compnerd@strontium.compnerd.org>
Date: Sat, 25 Apr 2009 10:17:44 -0700
Subject: [PATCH] support for installing to lib and lib64

---
 Makefile.am.inc                          |    1 +
 extras/ata_id/Makefile.am                |    2 +-
 extras/cdrom_id/Makefile.am              |    4 +-
 extras/collect/Makefile.am               |    2 +-
 extras/edd_id/Makefile.am                |    4 +-
 extras/firmware/Makefile.am              |    4 +-
 extras/floppy/Makefile.am                |    2 +-
 extras/fstab_import/Makefile.am          |    4 +-
 extras/path_id/Makefile.am               |    2 +-
 extras/rule_generator/Makefile.am        |   17 ++++-
 extras/rule_generator/write_cd_rules     |  117 ---------------------------
 extras/rule_generator/write_cd_rules.in  |  117 +++++++++++++++++++++++++++
 extras/rule_generator/write_net_rules    |  130 ------------------------------
 extras/rule_generator/write_net_rules.in |  130 ++++++++++++++++++++++++++++++
 extras/scsi_id/Makefile.am               |    2 +-
 extras/usb_id/Makefile.am                |    2 +-
 extras/volume_id/Makefile.am             |    2 +-
 rules/Makefile.am                        |   12 +++-
 rules/rules.d/50-udev-default.rules      |  121 ---------------------------
 rules/rules.d/50-udev-default.rules.in   |  121 +++++++++++++++++++++++++++
 udev/udev-rules.c                        |    4 +-
 udev/udev-util.c                         |    2 +-
 udev/udevd.c                             |    2 +-
 23 files changed, 413 insertions(+), 391 deletions(-)
 delete mode 100644 extras/rule_generator/write_cd_rules
 create mode 100644 extras/rule_generator/write_cd_rules.in
 delete mode 100644 extras/rule_generator/write_net_rules
 create mode 100644 extras/rule_generator/write_net_rules.in
 delete mode 100644 rules/rules.d/50-udev-default.rules
 create mode 100644 rules/rules.d/50-udev-default.rules.in

diff --git a/Makefile.am.inc b/Makefile.am.inc
index 7ecd55d..c09b396 100644
--- a/Makefile.am.inc
+++ b/Makefile.am.inc
@@ -2,6 +2,7 @@ AM_CPPFLAGS = \
 	-include $(top_builddir)/config.h \
 	-DSYSCONFDIR=\""$(sysconfdir)"\" \
 	-DUDEV_PREFIX=\""$(udev_prefix)"\" \
+	-DLIBDIR=\""$(libdir_name)"\" \
 	-D_LIBUDEV_COMPILATION
 
 AM_CFLAGS =
diff --git a/extras/ata_id/Makefile.am b/extras/ata_id/Makefile.am
index d31fd2c..0634b03 100644
--- a/extras/ata_id/Makefile.am
+++ b/extras/ata_id/Makefile.am
@@ -1,6 +1,6 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 udevhome_PROGRAMS = \
 	ata_id
 
diff --git a/extras/cdrom_id/Makefile.am b/extras/cdrom_id/Makefile.am
index 51b6a20..e26490e 100644
--- a/extras/cdrom_id/Makefile.am
+++ b/extras/cdrom_id/Makefile.am
@@ -1,10 +1,10 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 udevhome_PROGRAMS = \
 	cdrom_id
 
-udevrulesdir = $(udev_prefix)/lib/udev/rules.d
+udevrulesdir = $(udev_prefix)/$(libdir_name)/udev/rules.d
 dist_udevrules_DATA = \
 	60-cdrom_id.rules
 
diff --git a/extras/collect/Makefile.am b/extras/collect/Makefile.am
index d9792b8..c716e53 100644
--- a/extras/collect/Makefile.am
+++ b/extras/collect/Makefile.am
@@ -1,6 +1,6 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 udevhome_PROGRAMS = \
 	collect
 
diff --git a/extras/edd_id/Makefile.am b/extras/edd_id/Makefile.am
index 9bfe432..2dff5a6 100644
--- a/extras/edd_id/Makefile.am
+++ b/extras/edd_id/Makefile.am
@@ -1,10 +1,10 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 udevhome_PROGRAMS = \
 	edd_id
 
-udevrulesdir = $(udev_prefix)/lib/udev/rules.d
+udevrulesdir = $(udev_prefix)/$(libdir_name)/udev/rules.d
 dist_udevrules_DATA = \
 	61-persistent-storage-edd.rules
 
diff --git a/extras/firmware/Makefile.am b/extras/firmware/Makefile.am
index 42f5876..f4514fd 100644
--- a/extras/firmware/Makefile.am
+++ b/extras/firmware/Makefile.am
@@ -1,9 +1,9 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 dist_udevhome_SCRIPTS = \
 	firmware.sh
 
-udevrulesdir = $(udev_prefix)/lib/udev/rules.d
+udevrulesdir = $(udev_prefix)/$(libdir_name)/udev/rules.d
 dist_udevrules_DATA = \
 	50-firmware.rules
diff --git a/extras/floppy/Makefile.am b/extras/floppy/Makefile.am
index 8cb9cbd..e09f8b1 100644
--- a/extras/floppy/Makefile.am
+++ b/extras/floppy/Makefile.am
@@ -1,6 +1,6 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 udevhome_PROGRAMS = \
 	create_floppy_devices
 
diff --git a/extras/fstab_import/Makefile.am b/extras/fstab_import/Makefile.am
index c63dc7c..1f71df3 100644
--- a/extras/fstab_import/Makefile.am
+++ b/extras/fstab_import/Makefile.am
@@ -1,10 +1,10 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 udevhome_PROGRAMS = \
 	fstab_import
 
-udevrulesdir = $(udev_prefix)/lib/udev/rules.d
+udevrulesdir = $(udev_prefix)/$(libdir_name)/udev/rules.d
 dist_udevrules_DATA = \
 	79-fstab_import.rules
 
diff --git a/extras/path_id/Makefile.am b/extras/path_id/Makefile.am
index f489290..972334f 100644
--- a/extras/path_id/Makefile.am
+++ b/extras/path_id/Makefile.am
@@ -1,6 +1,6 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 dist_udevhome_SCRIPTS = \
 	path_id
 
diff --git a/extras/rule_generator/Makefile.am b/extras/rule_generator/Makefile.am
index e8a8f17..03f002c 100644
--- a/extras/rule_generator/Makefile.am
+++ b/extras/rule_generator/Makefile.am
@@ -1,6 +1,6 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 dist_udevhome_SCRIPTS = \
 	write_cd_rules \
 	write_net_rules
@@ -8,8 +8,21 @@ dist_udevhome_SCRIPTS = \
 dist_udevhome_DATA = \
 	rule_generator.functions
 
-udevrulesdir = $(udev_prefix)/lib/udev/rules.d
+udevrulesdir = $(udev_prefix)/$(libdir_name)/udev/rules.d
 dist_udevrules_DATA = \
 	75-cd-aliases-generator.rules \
 	75-persistent-net-generator.rules
 
+distclean-local:
+	rm -f Makefile.in
+
+write_cd_rules: write_cd_rules.in
+	$(SED) -e "s:@@libdir@@:$(libdir_name):g" < $< > $@
+
+write_net_rules: write_net_rules.in
+	$(SED) -e "s:@@libdir@@:$(libdir_name):g" < $< > $@
+
+CLEANFILES = write_cd_rules write_net_rules
+
+EXTRA_DIST = write_cd_rules.in write_net_rules.in
+
diff --git a/extras/rule_generator/write_cd_rules b/extras/rule_generator/write_cd_rules
deleted file mode 100644
index 398cd27..0000000
--- a/extras/rule_generator/write_cd_rules
+++ /dev/null
@@ -1,117 +0,0 @@
-#!/bin/sh -e
-
-# This script is run if an optical drive lacks a rule for persistent naming.
-#
-# It adds symlinks for optical drives based on the device class determined
-# by cdrom_id and used ID_PATH to identify the device.
-#
-# (C) 2006 Marco d'Itri <md@Linux.IT>
-#
-# This program is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation version 2 of the License.
-
-# debug, if UDEV_LOG=<debug>
-if [ -n "$UDEV_LOG" ]; then
-	if [ "$UDEV_LOG" -ge 7 ]; then
-		set -x
-	fi
-fi
-
-RULES_FILE="/etc/udev/rules.d/70-persistent-cd.rules"
-
-. /lib/udev/rule_generator.functions
-
-find_next_available() {
-	raw_find_next_available "$(find_all_rules 'SYMLINK\+=' "$1")"
-}
-
-write_rule() {
-	local match="$1"
-	local link="$2"
-	local comment="$3"
-
-	{
-	if [ "$PRINT_HEADER" ]; then
-		PRINT_HEADER=
-		echo "# This file was automatically generated by the $0"
-		echo "# program, run by the cd-aliases-generator.rules rules file."
-		echo "#"
-		echo "# You can modify it, as long as you keep each rule on a single"
-		echo "# line, and set the \$GENERATED variable."
-		echo ""
-	fi
-
-	[ "$comment" ] && echo "# $comment"
-	echo "$match, SYMLINK+=\"$link\", ENV{GENERATED}=\"1\""
-	} >> $RULES_FILE
-	SYMLINKS="$SYMLINKS $link"
-}
-
-if [ -z "$DEVPATH" ]; then
-	echo "Missing \$DEVPATH." >&2
-	exit 1
-fi
-if [ -z "$ID_CDROM" ]; then
-	echo "$DEVPATH is not a CD reader." >&2
-	exit 1
-fi
-
-if [ "$1" ]; then
-	METHOD="$1"
-else
-	METHOD='by-path'
-fi
-
-case "$METHOD" in
-	by-path)
-	if [ -z "$ID_PATH" ]; then
-		echo "$DEVPATH not supported by path_id. by-id may work." >&2
-		exit 1
-	fi
-	RULE="ENV{ID_PATH}==\"$ID_PATH\""
-	;;
-
-	by-id)
-	if [ "$ID_SERIAL" ]; then
-		RULE="ENV{ID_SERIAL}==\"$ID_SERIAL\""
-	elif [ "$ID_MODEL" -a "$ID_REVISION" ]; then
-		RULE="ENV{ID_MODEL}==\"$ID_MODEL\", ENV{ID_REVISION}==\"$ID_REVISION\""
-	else
-		echo "$DEVPATH not supported by ata_id. by-path may work." >&2
-		exit 1
-	fi
-	;;
-
-	*)
-	echo "Invalid argument (must be either by-path or by-id)." >&2
-	exit 1
-	;;
-esac
-
-# Prevent concurrent processes from modifying the file at the same time.
-lock_rules_file
-
-# Check if the rules file is writeable.
-choose_rules_file
-
-link_num=$(find_next_available 'cdrom[0-9]*')
-
-match="ENV{ID_CDROM}==\"?*\", $RULE"
-
-comment="$ID_MODEL ($ID_PATH)"
-
-	write_rule "$match" "cdrom$link_num" "$comment"
-[ "$ID_CDROM_CD_R" -o "$ID_CDROM_CD_RW" ] && \
-	write_rule "$match" "cdrw$link_num"
-[ "$ID_CDROM_DVD" ] && \
-	write_rule "$match" "dvd$link_num"
-[ "$ID_CDROM_DVD_R" -o "$ID_CDROM_DVD_RW" -o "$ID_CDROM_DVD_RAM" ] && \
-	write_rule "$match" "dvdrw$link_num"
-
-unlock_rules_file
-
-echo $SYMLINKS
-
-exit 0
-
diff --git a/extras/rule_generator/write_cd_rules.in b/extras/rule_generator/write_cd_rules.in
new file mode 100644
index 0000000..77967f0
--- /dev/null
+++ b/extras/rule_generator/write_cd_rules.in
@@ -0,0 +1,117 @@
+#!/bin/sh -e
+
+# This script is run if an optical drive lacks a rule for persistent naming.
+#
+# It adds symlinks for optical drives based on the device class determined
+# by cdrom_id and used ID_PATH to identify the device.
+#
+# (C) 2006 Marco d'Itri <md@Linux.IT>
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation version 2 of the License.
+
+# debug, if UDEV_LOG=<debug>
+if [ -n "$UDEV_LOG" ]; then
+	if [ "$UDEV_LOG" -ge 7 ]; then
+		set -x
+	fi
+fi
+
+RULES_FILE="/etc/udev/rules.d/70-persistent-cd.rules"
+
+. /@@libdir@@/udev/rule_generator.functions
+
+find_next_available() {
+	raw_find_next_available "$(find_all_rules 'SYMLINK\+=' "$1")"
+}
+
+write_rule() {
+	local match="$1"
+	local link="$2"
+	local comment="$3"
+
+	{
+	if [ "$PRINT_HEADER" ]; then
+		PRINT_HEADER=
+		echo "# This file was automatically generated by the $0"
+		echo "# program, run by the cd-aliases-generator.rules rules file."
+		echo "#"
+		echo "# You can modify it, as long as you keep each rule on a single"
+		echo "# line, and set the \$GENERATED variable."
+		echo ""
+	fi
+
+	[ "$comment" ] && echo "# $comment"
+	echo "$match, SYMLINK+=\"$link\", ENV{GENERATED}=\"1\""
+	} >> $RULES_FILE
+	SYMLINKS="$SYMLINKS $link"
+}
+
+if [ -z "$DEVPATH" ]; then
+	echo "Missing \$DEVPATH." >&2
+	exit 1
+fi
+if [ -z "$ID_CDROM" ]; then
+	echo "$DEVPATH is not a CD reader." >&2
+	exit 1
+fi
+
+if [ "$1" ]; then
+	METHOD="$1"
+else
+	METHOD='by-path'
+fi
+
+case "$METHOD" in
+	by-path)
+	if [ -z "$ID_PATH" ]; then
+		echo "$DEVPATH not supported by path_id. by-id may work." >&2
+		exit 1
+	fi
+	RULE="ENV{ID_PATH}==\"$ID_PATH\""
+	;;
+
+	by-id)
+	if [ "$ID_SERIAL" ]; then
+		RULE="ENV{ID_SERIAL}==\"$ID_SERIAL\""
+	elif [ "$ID_MODEL" -a "$ID_REVISION" ]; then
+		RULE="ENV{ID_MODEL}==\"$ID_MODEL\", ENV{ID_REVISION}==\"$ID_REVISION\""
+	else
+		echo "$DEVPATH not supported by ata_id. by-path may work." >&2
+		exit 1
+	fi
+	;;
+
+	*)
+	echo "Invalid argument (must be either by-path or by-id)." >&2
+	exit 1
+	;;
+esac
+
+# Prevent concurrent processes from modifying the file at the same time.
+lock_rules_file
+
+# Check if the rules file is writeable.
+choose_rules_file
+
+link_num=$(find_next_available 'cdrom[0-9]*')
+
+match="ENV{ID_CDROM}==\"?*\", $RULE"
+
+comment="$ID_MODEL ($ID_PATH)"
+
+	write_rule "$match" "cdrom$link_num" "$comment"
+[ "$ID_CDROM_CD_R" -o "$ID_CDROM_CD_RW" ] && \
+	write_rule "$match" "cdrw$link_num"
+[ "$ID_CDROM_DVD" ] && \
+	write_rule "$match" "dvd$link_num"
+[ "$ID_CDROM_DVD_R" -o "$ID_CDROM_DVD_RW" -o "$ID_CDROM_DVD_RAM" ] && \
+	write_rule "$match" "dvdrw$link_num"
+
+unlock_rules_file
+
+echo $SYMLINKS
+
+exit 0
+
diff --git a/extras/rule_generator/write_net_rules b/extras/rule_generator/write_net_rules
deleted file mode 100644
index cb34675..0000000
--- a/extras/rule_generator/write_net_rules
+++ /dev/null
@@ -1,130 +0,0 @@
-#!/bin/sh -e
-#
-# Copyright (C) 2006 Marco d'Itri <md@Linux.IT>
-# Copyright (C) 2007 Kay Sievers <kay.sievers@vrfy.org>
-#
-# This program is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation version 2 of the License.
-#
-# This script is run to create persistent network device naming rules
-# based on properties of the device.
-# If the interface needs to be renamed, INTERFACE_NEW=<name> will be printed
-# on stdout to allow udev to IMPORT it.
-
-# variables used to communicate:
-#   MATCHADDR             MAC address used for the match
-#   MATCHID               bus_id used for the match
-#   MATCHDEVID            dev_id used for the match
-#   MATCHDRV              driver name used for the match
-#   MATCHIFTYPE           interface type match
-#   COMMENT               comment to add to the generated rule
-#   INTERFACE_NAME        requested name supplied by external tool
-#   INTERFACE_NEW         new interface name returned by rule writer
-
-# debug, if UDEV_LOG=<debug>
-if [ -n "$UDEV_LOG" ]; then
-	if [ "$UDEV_LOG" -ge 7 ]; then
-		set -x
-	fi
-fi
-
-RULES_FILE='/etc/udev/rules.d/70-persistent-net.rules'
-
-. /lib/udev/rule_generator.functions
-
-interface_name_taken() {
-	local value="$(find_all_rules 'NAME=' $INTERFACE)"
-	if [ "$value" ]; then
-		return 0
-	else
-		return 1
-	fi
-}
-
-find_next_available() {
-	raw_find_next_available "$(find_all_rules 'NAME=' "$1")"
-}
-
-write_rule() {
-	local match="$1"
-	local name="$2"
-	local comment="$3"
-
-	{
-	if [ "$PRINT_HEADER" ]; then
-		PRINT_HEADER=
-		echo "# This file was automatically generated by the $0"
-		echo "# program, run by the persistent-net-generator.rules rules file."
-		echo "#"
-		echo "# You can modify it, as long as you keep each rule on a single"
-		echo "# line, and change only the value of the NAME= key."
-	fi
-
-	echo ""
-	[ "$comment" ] && echo "# $comment"
-	echo "SUBSYSTEM==\"net\", ACTION==\"add\"$match, NAME=\"$name\""
-	} >> $RULES_FILE
-}
-
-if [ -z "$INTERFACE" ]; then
-	echo "missing \$INTERFACE" >&2
-	exit 1
-fi
-
-# Prevent concurrent processes from modifying the file at the same time.
-lock_rules_file
-
-# Check if the rules file is writeable.
-choose_rules_file
-
-# the DRIVERS key is needed to not match bridges and VLAN sub-interfaces
-if [ "$MATCHADDR" ]; then
-	match="$match, DRIVERS==\"?*\", ATTR{address}==\"$MATCHADDR\""
-fi
-
-if [ "$MATCHDRV" ]; then
-	match="$match, DRIVERS==\"$MATCHDRV\""
-fi
-
-if [ "$MATCHDEVID" ]; then
-	match="$match, ATTR{dev_id}==\"$MATCHDEVID\""
-fi
-
-if [ "$MATCHID" ]; then
-	match="$match, KERNELS==\"$MATCHID\""
-fi
-
-if [ "$MATCHIFTYPE" ]; then
-	match="$match, ATTR{type}==\"$MATCHIFTYPE\""
-fi
-
-if [ -z "$match" ]; then
-	echo "missing valid match" >&2
-	unlock_rules_file
-	exit 1
-fi
-
-basename=${INTERFACE%%[0-9]*}
-match="$match, KERNEL==\"$basename*\""
-
-if [ "$INTERFACE_NAME" ]; then
-	# external tools may request a custom name
-	COMMENT="$COMMENT (custom name provided by external tool)"
-	if [ "$INTERFACE_NAME" != "$INTERFACE" ]; then
-		INTERFACE=$INTERFACE_NAME;
-		echo "INTERFACE_NEW=$INTERFACE"
-	fi
-else
-	# if a rule using the current name already exists, find a new name
-	if interface_name_taken; then
-		INTERFACE="$basename$(find_next_available "$basename[0-9]*")"
-		echo "INTERFACE_NEW=$INTERFACE"
-	fi
-fi
-
-write_rule "$match" "$INTERFACE" "$COMMENT"
-
-unlock_rules_file
-
-exit 0
diff --git a/extras/rule_generator/write_net_rules.in b/extras/rule_generator/write_net_rules.in
new file mode 100644
index 0000000..6f797d6
--- /dev/null
+++ b/extras/rule_generator/write_net_rules.in
@@ -0,0 +1,130 @@
+#!/bin/sh -e
+#
+# Copyright (C) 2006 Marco d'Itri <md@Linux.IT>
+# Copyright (C) 2007 Kay Sievers <kay.sievers@vrfy.org>
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation version 2 of the License.
+#
+# This script is run to create persistent network device naming rules
+# based on properties of the device.
+# If the interface needs to be renamed, INTERFACE_NEW=<name> will be printed
+# on stdout to allow udev to IMPORT it.
+
+# variables used to communicate:
+#   MATCHADDR             MAC address used for the match
+#   MATCHID               bus_id used for the match
+#   MATCHDEVID            dev_id used for the match
+#   MATCHDRV              driver name used for the match
+#   MATCHIFTYPE           interface type match
+#   COMMENT               comment to add to the generated rule
+#   INTERFACE_NAME        requested name supplied by external tool
+#   INTERFACE_NEW         new interface name returned by rule writer
+
+# debug, if UDEV_LOG=<debug>
+if [ -n "$UDEV_LOG" ]; then
+	if [ "$UDEV_LOG" -ge 7 ]; then
+		set -x
+	fi
+fi
+
+RULES_FILE='/etc/udev/rules.d/70-persistent-net.rules'
+
+. /@@libdir@@/udev/rule_generator.functions
+
+interface_name_taken() {
+	local value="$(find_all_rules 'NAME=' $INTERFACE)"
+	if [ "$value" ]; then
+		return 0
+	else
+		return 1
+	fi
+}
+
+find_next_available() {
+	raw_find_next_available "$(find_all_rules 'NAME=' "$1")"
+}
+
+write_rule() {
+	local match="$1"
+	local name="$2"
+	local comment="$3"
+
+	{
+	if [ "$PRINT_HEADER" ]; then
+		PRINT_HEADER=
+		echo "# This file was automatically generated by the $0"
+		echo "# program, run by the persistent-net-generator.rules rules file."
+		echo "#"
+		echo "# You can modify it, as long as you keep each rule on a single"
+		echo "# line, and change only the value of the NAME= key."
+	fi
+
+	echo ""
+	[ "$comment" ] && echo "# $comment"
+	echo "SUBSYSTEM==\"net\", ACTION==\"add\"$match, NAME=\"$name\""
+	} >> $RULES_FILE
+}
+
+if [ -z "$INTERFACE" ]; then
+	echo "missing \$INTERFACE" >&2
+	exit 1
+fi
+
+# Prevent concurrent processes from modifying the file at the same time.
+lock_rules_file
+
+# Check if the rules file is writeable.
+choose_rules_file
+
+# the DRIVERS key is needed to not match bridges and VLAN sub-interfaces
+if [ "$MATCHADDR" ]; then
+	match="$match, DRIVERS==\"?*\", ATTR{address}==\"$MATCHADDR\""
+fi
+
+if [ "$MATCHDRV" ]; then
+	match="$match, DRIVERS==\"$MATCHDRV\""
+fi
+
+if [ "$MATCHDEVID" ]; then
+	match="$match, ATTR{dev_id}==\"$MATCHDEVID\""
+fi
+
+if [ "$MATCHID" ]; then
+	match="$match, KERNELS==\"$MATCHID\""
+fi
+
+if [ "$MATCHIFTYPE" ]; then
+	match="$match, ATTR{type}==\"$MATCHIFTYPE\""
+fi
+
+if [ -z "$match" ]; then
+	echo "missing valid match" >&2
+	unlock_rules_file
+	exit 1
+fi
+
+basename=${INTERFACE%%[0-9]*}
+match="$match, KERNEL==\"$basename*\""
+
+if [ "$INTERFACE_NAME" ]; then
+	# external tools may request a custom name
+	COMMENT="$COMMENT (custom name provided by external tool)"
+	if [ "$INTERFACE_NAME" != "$INTERFACE" ]; then
+		INTERFACE=$INTERFACE_NAME;
+		echo "INTERFACE_NEW=$INTERFACE"
+	fi
+else
+	# if a rule using the current name already exists, find a new name
+	if interface_name_taken; then
+		INTERFACE="$basename$(find_next_available "$basename[0-9]*")"
+		echo "INTERFACE_NEW=$INTERFACE"
+	fi
+fi
+
+write_rule "$match" "$INTERFACE" "$COMMENT"
+
+unlock_rules_file
+
+exit 0
diff --git a/extras/scsi_id/Makefile.am b/extras/scsi_id/Makefile.am
index 29d5fe7..4c0e8ee 100644
--- a/extras/scsi_id/Makefile.am
+++ b/extras/scsi_id/Makefile.am
@@ -1,6 +1,6 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 udevhome_PROGRAMS = \
 	scsi_id
 
diff --git a/extras/usb_id/Makefile.am b/extras/usb_id/Makefile.am
index 07b286d..59cc824 100644
--- a/extras/usb_id/Makefile.am
+++ b/extras/usb_id/Makefile.am
@@ -1,6 +1,6 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 udevhome_PROGRAMS = \
 	usb_id
 
diff --git a/extras/volume_id/Makefile.am b/extras/volume_id/Makefile.am
index 4a8ba94..b7ca6a1 100644
--- a/extras/volume_id/Makefile.am
+++ b/extras/volume_id/Makefile.am
@@ -3,7 +3,7 @@ include $(top_srcdir)/Makefile.am.inc
 SUBDIRS = \
 	lib
 
-udevhomedir = $(udev_prefix)/lib/udev
+udevhomedir = $(udev_prefix)/$(libdir_name)/udev
 udevhome_PROGRAMS = \
 	vol_id
 
diff --git a/rules/Makefile.am b/rules/Makefile.am
index 7f3cd59..ac7f5b9 100644
--- a/rules/Makefile.am
+++ b/rules/Makefile.am
@@ -1,6 +1,6 @@
 include $(top_srcdir)/Makefile.am.inc
 
-udevrulesdir = $(udev_prefix)/lib/udev/rules.d
+udevrulesdir = $(udev_prefix)/$(libdir_name)/udev/rules.d
 dist_udevrules_DATA = \
 	rules.d/50-udev-default.rules \
 	rules.d/60-persistent-storage.rules \
@@ -18,4 +18,12 @@ EXTRA_DIST = \
 	packages \
 	redhat \
 	suse \
-	gentoo
+	gentoo \
+	rules.d/50-udev-default.rules.in
+
+distclean-local:
+	rm -f Makefile.in
+
+rules.d/50-udev-default.rules: rules.d/50-udev-default.rules.in
+	$(SED) -e "s:@@libdir@@:$(libdir_name):g" < $< > $@
+
diff --git a/rules/rules.d/50-udev-default.rules b/rules/rules.d/50-udev-default.rules
deleted file mode 100644
index 240cb3b..0000000
--- a/rules/rules.d/50-udev-default.rules
+++ /dev/null
@@ -1,121 +0,0 @@
-# do not edit this file, it will be overwritten on update
-# initramfs:default
-
-SUBSYSTEM=="block", SYMLINK+="block/%M:%m"
-SUBSYSTEM!="block", SYMLINK+="char/%M:%m"
-
-KERNEL=="pty[pqrstuvwxyzabcdef][0123456789abcdef]", GROUP="tty", MODE="0660"
-KERNEL=="tty[pqrstuvwxyzabcdef][0123456789abcdef]", GROUP="tty", MODE="0660"
-KERNEL=="ptmx",			GROUP="tty", MODE="0666"
-KERNEL=="tty",			GROUP="tty", MODE="0666"
-KERNEL=="tty[0-9]*",		GROUP="tty", MODE="0620"
-KERNEL=="vcs|vcs[0-9]*|vcsa|vcsa[0-9]*", GROUP="tty"
-KERNEL=="console",		MODE="0600"
-
-# serial
-KERNEL=="tty[A-Z]*[0-9]|pppox[0-9]*|ircomm[0-9]*|noz[0-9]*", GROUP="dialout"
-KERNEL=="ppp",			MODE="0600"
-KERNEL=="mwave",		NAME="modems/mwave", GROUP="dialout"
-KERNEL=="hvc*|hvsi*",		GROUP="dialout"
-
-# mem
-KERNEL=="null|zero|full|random|urandom", MODE="0666"
-KERNEL=="mem|kmem|port|nvram",	GROUP="kmem", MODE="0640"
-
-# input
-KERNEL=="mouse*|mice|event*",	NAME="input/%k", MODE="0640"
-KERNEL=="ts[0-9]*|uinput",	NAME="input/%k", MODE="0640"
-KERNEL=="js[0-9]*",		NAME="input/%k", MODE="0644"
-
-# video4linux
-SUBSYSTEM=="video4linux",	GROUP="video"
-KERNEL=="vttuner*",		GROUP="video"
-KERNEL=="vtx*|vbi*",		GROUP="video"
-KERNEL=="winradio*",		GROUP="video"
-
-# graphics
-KERNEL=="agpgart",		MODE="0600", GROUP="video"
-KERNEL=="card[0-9]*",		NAME="dri/%k"
-KERNEL=="pmu",			GROUP="video"
-KERNEL=="nvidia*|nvidiactl*",	GROUP="video"
-SUBSYSTEM=="graphics",		GROUP="video"
-SUBSYSTEM=="drm",		GROUP="video"
-
-# DVB (video)
-SUBSYSTEM=="dvb", ENV{DVB_ADAPTER_NUM}=="?*", NAME="dvb/adapter$env{DVB_ADAPTER_NUM}/$env{DVB_DEVICE_TYPE}$env{DVB_DEVICE_NUM}", GROUP="video"
-SUBSYSTEM=="dvb", ENV{DVB_ADAPTER_NUM}=="", PROGRAM="/bin/sh -c 'K=%k; K=$${K#dvb}; printf dvb/adapter%%i/%%s $${K%%%%.*} $${K#*.}'", NAME="%c", GROUP="video"
-
-# Firewire
-KERNEL=="dv1394[0-9]*",		NAME="dv1394/%n", GROUP="video"
-KERNEL=="video1394[0-9]*",	NAME="video1394/%n", GROUP="video"
-
-# libusb device nodes
-SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", NAME="bus/usb/$env{BUSNUM}/$env{DEVNUM}", MODE="0664"
-
-# printer
-KERNEL=="parport[0-9]*",	GROUP="lp"
-SUBSYSTEM=="printer",		KERNEL=="lp*", GROUP="lp"
-SUBSYSTEM=="ppdev",		GROUP="lp"
-SUBSYSTEM=="usb",		KERNEL=="lp*", NAME="usb/%k", SYMLINK+="usb%k", GROUP="lp"
-KERNEL=="lp[0-9]*",		GROUP="lp"
-KERNEL=="irlpt[0-9]*",		GROUP="lp"
-
-# block
-SUBSYSTEM=="block", GROUP="disk"
-
-# floppy
-KERNEL=="fd[0-9]", GROUP="floppy"
-KERNEL=="fd[0-9]", ACTION=="add", ATTRS{cmos}=="?*", RUN+="create_floppy_devices -c -t $attr{cmos} -m %M -M 0640 -G floppy $root/%k"
-KERNEL=="hd*", SUBSYSTEMS=="ide", ATTRS{media}=="floppy", OPTIONS+="all_partitions"
-
-# cdrom
-SUBSYSTEM=="block", KERNEL=="sr[0-9]*", SYMLINK+="scd%n", GROUP="cdrom"
-SUBSYSTEM=="block", KERNEL=="hd*", SUBSYSTEMS=="ide", ATTRS{media}=="cdrom", GROUP="cdrom"
-SUBSYSTEMS=="scsi", ATTRS{type}=="4|5", GROUP="cdrom"
-KERNEL=="pktcdvd[0-9]*", NAME="pktcdvd/%k", GROUP="cdrom"
-KERNEL=="pktcdvd", NAME="pktcdvd/control", GROUP="cdrom"
-
-# tape
-KERNEL=="ht[0-9]*|nht[0-9]*", GROUP="tape"
-KERNEL=="pt[0-9]*|npt[0-9]*|pht[0-9]*", GROUP="tape"
-SUBSYSTEMS=="scsi", ATTRS{type}=="1|8", GROUP="tape"
-
-# block-releated
-KERNEL=="sch[0-9]*", GROUP="disk"
-SUBSYSTEMS=="scsi", ATTRS{type}=="0", GROUP="disk"
-KERNEL=="pg[0-9]*", GROUP="disk"
-KERNEL=="qft[0-9]*|nqft[0-9]*|zqft[0-9]*|nzqft[0-9]*|rawqft[0-9]*|nrawqft[0-9]*", GROUP="disk"
-KERNEL=="rawctl", NAME="raw/rawctl", GROUP="disk"
-SUBSYSTEM=="raw", KERNEL=="raw[0-9]*", NAME="raw/%k", GROUP="disk"
-SUBSYSTEM=="bsg", NAME="bsg/%k"
-SUBSYSTEM=="aoe", NAME="etherd/%k", GROUP="disk", MODE="0220"
-SUBSYSTEM=="aoe", KERNEL=="err", MODE="0440"
-
-# network
-KERNEL=="tun",			NAME="net/%k", MODE="0666"
-
-# CPU
-KERNEL=="cpu[0-9]*",		NAME="cpu/%n/cpuid"
-KERNEL=="msr[0-9]*",		NAME="cpu/%n/msr"
-KERNEL=="microcode",		NAME="cpu/microcode", MODE="0600"
-
-# miscellaneous
-KERNEL=="fuse",			MODE="0666"
-SUBSYSTEM=="rtc", DRIVERS=="rtc_cmos", SYMLINK+="rtc"
-KERNEL=="auer[0-9]*",		NAME="usb/%k"
-KERNEL=="hw_random",		NAME="hwrng"
-KERNEL=="mmtimer",		MODE="0644"
-KERNEL=="rflash[0-9]*",		MODE="0400"
-KERNEL=="rrom[0-9]*",		MODE="0400"
-KERNEL=="sxctl",		NAME="specialix_sxctl"
-KERNEL=="rioctl",		NAME="specialix_rioctl"
-KERNEL=="iowarrior[0-9]*",	NAME="usb/%k"
-KERNEL=="hiddev[0-9]*",		NAME="usb/%k"
-KERNEL=="legousbtower[0-9]*",	NAME="usb/%k"
-KERNEL=="dabusb[0-9]*",		NAME="usb/%k"
-KERNEL=="usbdpfp[0-9]*",	NAME="usb/%k"
-KERNEL=="cpad[0-9]*",		NAME="usb/%k"
-
-# do not delete static device nodes
-ACTION=="remove", NAME=="?*", TEST=="/lib/udev/devices/$name", OPTIONS+="ignore_remove"
-ACTION=="remove", NAME=="", TEST=="/lib/udev/devices/%k", OPTIONS+="ignore_remove"
diff --git a/rules/rules.d/50-udev-default.rules.in b/rules/rules.d/50-udev-default.rules.in
new file mode 100644
index 0000000..f4ef998
--- /dev/null
+++ b/rules/rules.d/50-udev-default.rules.in
@@ -0,0 +1,121 @@
+# do not edit this file, it will be overwritten on update
+
+SUBSYSTEM=="block", SYMLINK+="block/%M:%m"
+SUBSYSTEM!="block", SYMLINK+="char/%M:%m"
+
+KERNEL=="pty[pqrstuvwxyzabcdef][0123456789abcdef]", GROUP="tty", MODE="0660"
+KERNEL=="tty[pqrstuvwxyzabcdef][0123456789abcdef]", GROUP="tty", MODE="0660"
+KERNEL=="ptmx",			GROUP="tty", MODE="0666"
+KERNEL=="tty",			GROUP="tty", MODE="0666"
+KERNEL=="tty[0-9]*",		GROUP="tty", MODE="0620"
+KERNEL=="vcs|vcs[0-9]*|vcsa|vcsa[0-9]*", GROUP="tty"
+KERNEL=="console",		MODE="0600"
+
+# serial
+KERNEL=="tty[A-Z]*[0-9]|pppox[0-9]*|ircomm[0-9]*|noz[0-9]*", GROUP="dialout"
+KERNEL=="ppp",			MODE="0600"
+KERNEL=="mwave",		NAME="modems/mwave", GROUP="dialout"
+KERNEL=="hvc*|hvsi*",		GROUP="dialout"
+
+# mem
+KERNEL=="null|zero|full|random|urandom", MODE="0666"
+KERNEL=="mem|kmem|port|nvram",	GROUP="kmem", MODE="0640"
+
+# input
+KERNEL=="mouse*|mice|event*",	NAME="input/%k", MODE="0640"
+KERNEL=="ts[0-9]*|uinput",	NAME="input/%k", MODE="0640"
+KERNEL=="js[0-9]*",		NAME="input/%k", MODE="0644"
+
+# video4linux
+SUBSYSTEM=="video4linux",	GROUP="video"
+KERNEL=="vttuner*",		GROUP="video"
+KERNEL=="vtx*|vbi*",		GROUP="video"
+KERNEL=="winradio*",		GROUP="video"
+
+# graphics
+KERNEL=="agpgart",		MODE="0600", GROUP="video"
+KERNEL=="card[0-9]*",		NAME="dri/%k"
+KERNEL=="pmu",			GROUP="video"
+KERNEL=="nvidia*|nvidiactl*",	GROUP="video"
+SUBSYSTEM=="graphics",		GROUP="video"
+SUBSYSTEM=="drm",		GROUP="video"
+
+# DVB (video)
+SUBSYSTEM=="dvb", ENV{DVB_ADAPTER_NUM}=="?*", NAME="dvb/adapter$env{DVB_ADAPTER_NUM}/$env{DVB_DEVICE_TYPE}$env{DVB_DEVICE_NUM}", GROUP="video"
+SUBSYSTEM=="dvb", ENV{DVB_ADAPTER_NUM}=="", PROGRAM="/bin/sh -c 'K=%k; K=$${K#dvb}; printf dvb/adapter%%i/%%s $${K%%%%.*} $${K#*.}'", NAME="%c", GROUP="video"
+
+# Firewire
+KERNEL=="dv1394[0-9]*",		NAME="dv1394/%n", GROUP="video"
+KERNEL=="video1394[0-9]*",	NAME="video1394/%n", GROUP="video"
+
+# libusb device nodes
+SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", NAME="bus/usb/$env{BUSNUM}/$env{DEVNUM}", MODE="0664"
+
+# printer
+KERNEL=="parport[0-9]*",	GROUP="lp"
+SUBSYSTEM=="printer",		KERNEL=="lp*", GROUP="lp"
+SUBSYSTEM=="ppdev",		GROUP="lp"
+SUBSYSTEM=="usb",		KERNEL=="lp*", NAME="usb/%k", SYMLINK+="usb%k", GROUP="lp"
+KERNEL=="lp[0-9]*",		GROUP="lp"
+KERNEL=="irlpt[0-9]*",		GROUP="lp"
+
+# block
+SUBSYSTEM=="block", GROUP="disk"
+
+# floppy
+KERNEL=="fd[0-9]", GROUP="floppy"
+KERNEL=="fd[0-9]", ACTION=="add", ATTRS{cmos}=="?*", RUN+="create_floppy_devices -c -t $attr{cmos} -m %M -M 0640 -G floppy $root/%k"
+KERNEL=="hd*", SUBSYSTEMS=="ide", ATTRS{media}=="floppy", OPTIONS+="all_partitions"
+
+# cdrom
+SUBSYSTEM=="block", KERNEL=="sr[0-9]*", SYMLINK+="scd%n", GROUP="cdrom"
+SUBSYSTEM=="block", KERNEL=="hd*", SUBSYSTEMS=="ide", ATTRS{media}=="cdrom", GROUP="cdrom"
+SUBSYSTEMS=="scsi", ATTRS{type}=="4|5", GROUP="cdrom"
+KERNEL=="pktcdvd[0-9]*", NAME="pktcdvd/%k", GROUP="cdrom"
+KERNEL=="pktcdvd", NAME="pktcdvd/control", GROUP="cdrom"
+
+# tape
+KERNEL=="ht[0-9]*|nht[0-9]*", GROUP="tape"
+KERNEL=="pt[0-9]*|npt[0-9]*|pht[0-9]*", GROUP="tape"
+SUBSYSTEMS=="scsi", ATTRS{type}=="1|8", GROUP="tape"
+
+# block-releated
+KERNEL=="sch[0-9]*", GROUP="disk"
+SUBSYSTEMS=="scsi", ATTRS{type}=="0", GROUP="disk"
+KERNEL=="pg[0-9]*", GROUP="disk"
+KERNEL=="qft[0-9]*|nqft[0-9]*|zqft[0-9]*|nzqft[0-9]*|rawqft[0-9]*|nrawqft[0-9]*", GROUP="disk"
+KERNEL=="rawctl", NAME="raw/rawctl", GROUP="disk"
+SUBSYSTEM=="raw", KERNEL=="raw[0-9]*", NAME="raw/%k", GROUP="disk"
+SUBSYSTEM=="bsg", NAME="bsg/%k"
+SUBSYSTEM=="aoe", NAME="etherd/%k", GROUP="disk", MODE="0220"
+SUBSYSTEM=="aoe", KERNEL=="err", MODE="0440"
+
+# network
+KERNEL=="tun",			NAME="net/%k", MODE="0666"
+
+# CPU
+KERNEL=="cpu[0-9]*",		NAME="cpu/%n/cpuid"
+KERNEL=="msr[0-9]*",		NAME="cpu/%n/msr"
+KERNEL=="microcode",		NAME="cpu/microcode", MODE="0600"
+
+# miscellaneous
+KERNEL=="fuse",			MODE="0666"
+SUBSYSTEM=="rtc", DRIVERS=="rtc_cmos", SYMLINK+="rtc"
+KERNEL=="auer[0-9]*",		NAME="usb/%k"
+KERNEL=="hw_random",		NAME="hwrng"
+KERNEL=="mmtimer",		MODE="0644"
+KERNEL=="rflash[0-9]*",		MODE="0400"
+KERNEL=="rrom[0-9]*",		MODE="0400"
+KERNEL=="sxctl",		NAME="specialix_sxctl"
+KERNEL=="rioctl",		NAME="specialix_rioctl"
+KERNEL=="iowarrior[0-9]*",	NAME="usb/%k"
+KERNEL=="hiddev[0-9]*",		NAME="usb/%k"
+KERNEL=="legousbtower[0-9]*",	NAME="usb/%k"
+KERNEL=="dabusb[0-9]*",		NAME="usb/%k"
+KERNEL=="usbdpfp[0-9]*",	NAME="usb/%k"
+KERNEL=="cpad[0-9]*",		NAME="usb/%k"
+
+# do not delete static device nodes
+ACTION=="remove", NAME=="?*", TEST=="/@@libdir@@/udev/devices/$name", OPTIONS+="ignore_remove"
+ACTION=="remove", NAME=="", TEST=="/@@libdir@@/udev/devices/%k", OPTIONS+="ignore_remove"
+
diff --git a/udev/udev-rules.c b/udev/udev-rules.c
index e4594c3..af29e49 100644
--- a/udev/udev-rules.c
+++ b/udev/udev-rules.c
@@ -1330,7 +1330,7 @@ static int add_rule(struct udev_rules *rules, char *line,
 
 				/* allow programs in /lib/udev called without the path */
 				if (strchr(file, '/') == NULL) {
-					util_strlcpy(file, UDEV_PREFIX "/lib/udev/", sizeof(file));
+					util_strlcpy(file, UDEV_PREFIX "/" LIBDIR "/udev/", sizeof(file));
 					util_strlcat(file, value, sizeof(file));
 					pos = strchr(file, ' ');
 					if (pos)
@@ -1734,7 +1734,7 @@ struct udev_rules *udev_rules_new(struct udev *udev, int resolve_names)
 		add_matching_files(udev, &sort_list, filename, ".rules");
 
 		/* read default rules */
-		add_matching_files(udev, &sort_list, UDEV_PREFIX "/lib/udev/rules.d", ".rules");
+		add_matching_files(udev, &sort_list, UDEV_PREFIX "/" LIBDIR "/udev/rules.d", ".rules");
 
 		/* sort all rules files by basename into list of files */
 		udev_list_entry_foreach_safe(sort_loop, sort_tmp, udev_list_get_entry(&sort_list)) {
diff --git a/udev/udev-util.c b/udev/udev-util.c
index 3d5eb76..94bf9bf 100644
--- a/udev/udev-util.c
+++ b/udev/udev-util.c
@@ -295,7 +295,7 @@ int util_run_program(struct udev *udev, const char *command, char **envp,
 
 	/* allow programs in /lib/udev/ to be called without the path */
 	if (strchr(argv[0], '/') == NULL) {
-		util_strlcpy(program, UDEV_PREFIX "/lib/udev/", sizeof(program));
+		util_strlcpy(program, UDEV_PREFIX "/" LIBDIR "/udev/", sizeof(program));
 		util_strlcat(program, argv[0], sizeof(program));
 		argv[0] = program;
 	}
diff --git a/udev/udevd.c b/udev/udevd.c
index 6de1196..42df300 100644
--- a/udev/udevd.c
+++ b/udev/udevd.c
@@ -916,7 +916,7 @@ int main(int argc, char *argv[])
 		} else {
 			char filename[UTIL_PATH_SIZE];
 
-			inotify_add_watch(inotify_fd, UDEV_PREFIX "/lib/udev/rules.d",
+			inotify_add_watch(inotify_fd, UDEV_PREFIX "/" LIBDIR "/udev/rules.d",
 					  IN_CREATE | IN_DELETE | IN_MOVE | IN_CLOSE_WRITE);
 			inotify_add_watch(inotify_fd, SYSCONFDIR "/udev/rules.d",
 					  IN_CREATE | IN_DELETE | IN_MOVE | IN_CLOSE_WRITE);
-- 
1.6.2.1

