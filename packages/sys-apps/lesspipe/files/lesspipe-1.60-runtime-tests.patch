Source: dleverton
Upstream: not suitable in current form, but will discuss
Reason: check for optional helper programs at runtime instead of
        configure time, to avoid
        1) automagic dependencies
        2) having to make option flags for each of them
        3) hard-enabling them all and then getting runtime failures

--- lesspipe-1.60/lesspipe.sh.in~	2008-12-01 19:51:49.000000000 +0000
+++ lesspipe-1.60/lesspipe.sh.in	2009-01-11 18:13:24.000000000 +0000
@@ -45,14 +45,14 @@
   xxx="${1%=}"
   set "$xxx"
 fi
-#ifdef mktemp
+if [[ -n $(type -P mktemp) ]]; then
 tmpdir=$(mktemp -d -p "${TMPDIR:-/tmp}" lesspipe.XXXXXXXXXX)
 
 nexttmp () {
   # nexttmp -d returns a directory
   mktemp -p "$tmpdir" $1
 }
-#else
+else
 tmpdir=${TMPDIR:-/tmp}/lesspipe.$RANDOM
 mkdir $tmpdir
 
@@ -61,7 +61,7 @@
   [[ "$1" = -d ]] && mkdir $new
   echo $new
 }
-#endif
+fi
 [[ -d "$tmpdir" ]] || exit 1
 trap "rm -rf '$tmpdir'" 0
 trap - PIPE
@@ -128,8 +128,7 @@
   rest11="$rest1"
   if [[ "$cmd" = "" ]]; then
     type=$(filetype "$file1") || exit 1
-#ifdef lsbom
-    if [[ ! -f "$file1" ]]; then
+    if [[ -n $(type -P lsbom) ]] && [[ ! -f "$file1" ]]; then
       if [[ "$type" = *directory* ]]; then
 	if [[ "$file1" = *.pkg ]]; then
 	  if [[ -f "$file1/Contents/Archive.bom" ]]; then
@@ -140,7 +139,6 @@
 	fi
       fi
     fi
-#endif
     get_cmd "$type" "$file1" "$rest1"
     if [[ "$cmd" != "" ]]; then
       show "-$rest1"
@@ -201,8 +199,7 @@
   if [[ "$1" = *[blg]zip*compress* || "$1" = *compress\'d\ * || "$1" = *packed\ data* || "$1" = *LZMA*compress* ]]; then ## added '#..then' to fix vim's syntax parsing
     if [[ "$3" = $sep$sep ]]; then
       return
-#ifdef bzip2
-    elif [[ "$1" = *bzip*compress* ]]; then
+    elif [[ -n $(type -P bzip2) ]] && [[ "$1" = *bzip*compress* ]]; then
       set -A cmd bzip2 -cd "$2"
       if [[ "$2" != - ]]; then filen="$2"; fi
       case "$filen" in
@@ -210,26 +207,21 @@
         *.tbz) filen="${filen%.tbz}.tar";;
       esac
       return
-#endif
-#ifdef lzip
-    elif [[ "$1" = *lzip*compress* ]]; then
+    elif [[ -n $(type -P lzip) ]] && [[ "$1" = *lzip*compress* ]]; then
       set -A cmd lzip -cd "$2"
       if [[ "$2" != - ]]; then filen="$2"; fi
       case "$filen" in
         *.lz) filen="${filen%.lz}";;
         *.tlz) filen="${filen%.tlz}.tar";;
       esac
-#endif
-#ifdef lzma
 # preliminary minimal support for lzma (not in magic file yet)
-    elif [[ "$1" = *LZMA*compress* ]]; then
+    elif [[ -n $(type -P lzma) ]] && [[ "$1" = *LZMA*compress* ]]; then
       set -A cmd lzma -cd "$2"
       if [[ "$2" != - ]]; then filen="$2"; fi
       case "$filen" in
         *.lzma) filen="${filen%.lzma}";;
         *.tlz) filen="${filen%.tlz}.tar";;
       esac
-#endif
     elif [[ "$1" = *gzip\ compress* || "$1" =  *compress\'d\ * || "$1" = *packed\ data* ]]; then ## added '#..then' to fix vim's syntax parsing
       set -A cmd gzip -cd "$2"
       if [[ "$2" != - ]]; then filen="$2"; fi
@@ -255,42 +247,26 @@
         istemp "ar p" "$2" data.tar.gz | gzip -dc - > "$t"
       fi
       set -A cmd istar "$t" "$file2"
-#ifdef rpm2cpio,cpio
-    elif [[ "$1" = *RPM* ]]; then
+    elif [[ -n $(type -P rpm2cpio) && -n $(type -P cpio) ]] && [[ "$1" = *RPM* ]]; then
       set -A cmd isrpm "$2" "$file2"
-#elif rpmunpack,cpio
-    elif [[ "$1" = *RPM* ]]; then
+    elif [[ -n $(type -P rpmunpack) && -n $(type -P cpio) ]] && [[ "$1" = *RPM* ]]; then
       set -A cmd isrpm "$2" "$file2"
-#endif 
-#ifdef fastjar
-    elif [[ "$1" = *Jar\ archive* ]]; then
+    elif [[ -n $(type -P fastjar) ]] && [[ "$1" = *Jar\ archive* ]]; then
       set -A cmd isjar "$2" "$file2"
-#endif
-#ifdef unzip
-    elif [[ "$1" = *Zip* || "$1" = *ZIP* ]]; then
+    elif [[ -n $(type -P unzip) ]] && [[ "$1" = *Zip* || "$1" = *ZIP* ]]; then
       set -A cmd istemp "unzip -avp" "$2" "$file2"
-#endif 
-#ifdef unrar
-    elif [[ "$1" = *RAR\ archive* ]]; then
+    elif [[ -n $(type -P unrar) ]] && [[ "$1" = *RAR\ archive* ]]; then
       set -A cmd istemp "unrar p -inul" "$2" "$file2"
-#elif rar
-    elif [[ "$1" = *RAR\ archive* ]]; then
+    elif [[ -n $(type -P rar) ]] && [[ "$1" = *RAR\ archive* ]]; then
       set -A cmd istemp "rar p -inul" "$2" "$file2"
-#endif 
-#ifdef 7za
-    elif [[ "$1" = *7-zip\ archive* ]]; then
+    elif [[ -n $(type -P 7za) ]] && [[ "$1" = *7-zip\ archive* ]]; then
       set -A cmd istemp "7za e -so" "$2" "$file2"
-#endif
-#ifdef cabextract
-    elif [[ "$1" = *[Cc]abinet* ]]; then
+    elif [[ -n $(type -P cabextract) ]] && [[ "$1" = *[Cc]abinet* ]]; then
       set -A cmd iscab "$2" "$file2"
-#endif 
     elif [[ "$1" = *\ ar\ archive* ]]; then
       set -A cmd istemp "ar p" "$2" "$file2"
-#ifdef isoinfo
-    elif [[ "$1" = *ISO\ 9660* ]]; then
+    elif [[ -n $(type -P isoinfo) ]] && [[ "$1" = *ISO\ 9660* ]]; then
       set -A cmd isoinfo "-i$2" "-x$file2"
-#endif
     fi
     if [[ "$cmd" != "" ]]; then
       filen="$file2"
@@ -298,7 +274,7 @@
   fi
 }
 
-#ifdef cabextract
+if [[ -n $(type -P cabextract) ]]; then
 iscab () {
   typeset t
   if [[ "$1" = - ]]; then
@@ -308,13 +284,13 @@
   fi
   cabextract -pF "$2" "$1"
 }
+fi
 
-#endif
 istar () {
   $tarcmd Oxf "$1" "$2" 2>/dev/null
 }
 
-#ifdef dvi2tty
+if [[ -n $(type -P dvi2tty) ]]; then
 isdvi () {
   typeset t
   if [[ "$1" != *.dvi ]]; then
@@ -324,7 +300,7 @@
   fi
   dvi2tty -q "$1"
 }
-#endif
+fi
 
 # istemp wrapper for helpers that cannot read from stdin
 istemp () {
@@ -362,7 +338,7 @@
   fi
 }
 
-#ifdef rpm2cpio,cpio
+if [[ -n $(type -P rpm2cpio) && -n $(type -P cpio) ]]; then
 isrpm () {
   typeset t
   if [[ "$1" = - ]]; then
@@ -378,16 +354,16 @@
   rpm2cpio "$1"|cpio -i --quiet --rename-batch-file "$b" "$2"
   cat "$b.out"
 }
-#elif rpmunpack,cpio
+elif [[ -n $(type -P rpmunpack) && -n $(type -P cpio) ]]; then
 isrpm () {
   # rpmunpack will write to stdout if it gets file from stdin
   # extract file $2 from archive $1, assume that cpio is sufficiently new
   # (option --to-stdout existing) if rpmunpack is installed
   cat "$1" | rpmunpack | gzip -cd | cpio -i --quiet --to-stdout "$2"
 }
-#endif
+fi
 
-#ifdef fastjar
+if [[ -n $(type -P fastjar) ]]; then
 isjar () {
   case "$2" in
     /*) echo "lesspipe can't unjar files with absolute paths" >&2
@@ -408,33 +384,33 @@
     fi
   )
 }
-#endif
+fi
 
-#ifdef html2text
+if [[ -n $(type -P html2text) ]]; then
 PARSEHTML=yes
 parsehtml () { html2text -style pretty "$1"; }
-#elif elinks
+elif [[ -n $(type -P elinks) ]]; then
 PARSEHTML=yes
 parsehtml () { nodash "elinks -dump -force-html" "$1"; }
 #parsexml () { nodash "elinks -dump -default-mime-type text/xml" "$1"; }
-#elif links
+elif [[ -n $(type -P links) ]]; then
 PARSEHTML=yes
 parsehtml () {
   if [[ "$1" = - ]]; then set - -stdin; fi
   links -dump -force_html "$1"
 }
-#elif lynx
+elif [[ -n $(type -P lynx) ]]; then
 PARSEHTML=yes
 parsehtml () {
   if [[ "$1" = - ]]; then set - -stdin; fi
   lynx -dump -force_html "$1" && return
 }
-#elif w3m
+elif [[ -n $(type -P w3m) ]]; then
 PARSEHTML=yes
 parsehtml () { nodash "w3m -dump -T text/html" "$1" ; }
-#else
+else
 PARSEHTML=no
-#endif
+fi
 
 isfinal() {
   typeset t
@@ -442,7 +418,7 @@
     cat "$2"
     return
   elif [[ "$3" = $sep* ]]; then
-#ifdef perl
+    if [[ -n $(type -P perl) ]]; then
     if [[ "$3" = $sep ]]; then
       echo "==> append :. or :<filetype> to activate syntax highlighting"
     else
@@ -456,7 +432,7 @@
         return
       fi
     fi
-#endif
+    fi
     cat "$2"
     return
   fi
@@ -474,25 +450,20 @@
   elif [[ "$1" = *\ tar* || "$1" = *\	tar* ]]; then
     echo "==> use tar_file${sep}contained_file to view a file in the archive"
     $tarcmd tvf "$2"
-#ifdef rpm,rpm2cpio,cpio
-  elif [[ "$1" = *RPM* ]]; then
+  elif [[ -n $(type -P rpm) && -n $(type -P rpm2cpio) && -n $(type -P cpio) ]] && [[ "$1" = *RPM* ]]; then
     echo "==> use RPM_file${sep}contained_file to view a file in the RPM"
     istemp "rpm -qivp" "$2"
     echo "================================= Content ======================================"
     istemp rpm2cpio "$2"|cpio -i -tv --quiet
-#elif rpm2cpio,cpio
-  elif [[ "$1" = *RPM* ]]; then
+  elif [[ -n $(type -P rpm2cpio) && -n $(type -P cpio) ]] && [[ "$1" = *RPM* ]]; then
     echo "==> use RPM_file${sep}contained_file to view a file in the RPM"
     echo "================================= Content ======================================"
     istemp rpm2cpio "$2"|cpio -i -tv --quiet
-#elif rpmunpack,cpio
-  elif [[ "$1" = *RPM* ]]; then
+  elif [[ -n $(type -P rpmunpack) && -n $(type -P cpio) ]] && [[ "$1" = *RPM* ]]; then
     echo "==> use RPM_file${sep}contained_file to view a file in the RPM"
     echo "================================= Content ======================================"
     cat "$2" | rpmunpack | gzip -cd | cpio -i -tv --quiet
-#endif
-#ifdef groff
-  elif [[ "$1" = *roff* ]]; then
+  elif [[ -n $(type -P groff) ]] && [[ "$1" = *roff* ]]; then
     DEV=utf8
     if [[ $LANG != *UTF*8* && $LANG != *utf*8* ]]; then
       if [[ "$LANG" = ja* ]]; then
@@ -509,32 +480,28 @@
     fi
     echo "==> append $sep to filename to view the nroff source"
     groff -s -p -t -e -T$DEV -m$MACRO "$2"
-#endif
   elif [[ "$1" = *Debian* ]]; then
     echo "==> use Deb_file${sep}contained_file to view a file in the Deb"
-#ifdef dpkg
+    if [[ -n $(type -P dpkg) ]]; then
     nodash "dpkg -I" "$2"
-#else
+    else
     echo
     istemp "ar p" "$2" control.tar.gz | gzip -dc - | $tarcmd tvf - | sed -r 's/(.{48})\./\1control/'
-#endif
+    fi
     echo
     istemp "ar p" "$2" data.tar.gz | gzip -dc - | $tarcmd tvf -
-#ifdef perldoc
   # do not display all perl text containing pod using perldoc
   #elif [[ "$1" = *Perl\ POD\ document\ text* || "$1" = *Perl5\ module\ source\ text* ]]; then
-  elif [[ "$1" = *Perl\ POD\ document\ text* ]]; then
+  elif [[ -n $(type -P perldoc) ]] && [[ "$1" = *Perl\ POD\ document\ text* ]]; then
     echo "==> append $sep to filename to view the perl source"
     istemp perldoc "$2"
-#endif
   elif [[ "$1" = *\ script* ]]; then
     set "plain text" "$2"
   elif [[ "$1" = *text\ executable* ]]; then
     set "plain text" "$2"
-#ifdef pstotext
   # check interactively for pstotext, as it is in the pregenerated lesspipe.sh
   # that comes with this package, but often only ps2ascii is available
-  elif [[ "$1" = *PostScript* ]]; then
+  elif [[ -n $(type -P pstotext) ]] && [[ "$1" = *PostScript* ]]; then
     echo "==> append $sep to filename to view the postscript file"
     which pstotext >/dev/null 2>&1
     if [[ $? = 0 ]]; then
@@ -542,43 +509,31 @@
     else
       istemp ps2ascii "$2"
     fi
-#elif ps2ascii
-  elif [[ "$1" = *PostScript* ]]; then
+  elif [[ -n $(type -P ps2ascii) ]] && [[ "$1" = *PostScript* ]]; then
     echo "==> append $sep to filename to view the postscript file"
     istemp ps2ascii "$2"
-#endif
   elif [[ "$1" = *executable* ]]; then
     echo "==> append $sep to filename to view the binary file"
     nodash strings "$2"
   elif [[ "$1" = *\ ar\ archive* ]]; then
     echo "==> use library${sep}contained_file to view a file in the archive"
     istemp "ar vt" "$2"
-#ifdef nm
-  elif [[ "$1" = *shared* ]]; then
+  elif [[ -n $(type -P nm) ]] && [[ "$1" = *shared* ]]; then
     echo "==> This is a dynamic library, showing the output of nm"
     istemp nm "$2"
-#endif
-#ifdef fastjar
-  elif [[ "$1" = *Jar\ archive* ]]; then
+  elif [[ -n $(type -P fastjar) ]] && [[ "$1" = *Jar\ archive* ]]; then
     echo "==> use jar_file${sep}contained_file to view a file in the archive"
     nodash "fastjar -tf" "$2"
-#endif
-#ifdef unzip
-  elif [[ "$1" = *Zip* || "$1" = *ZIP* ]]; then
+  elif [[ -n $(type -P unzip) ]] && [[ "$1" = *Zip* || "$1" = *ZIP* ]]; then
     echo "==> use zip_file${sep}contained_file to view a file in the archive"
     istemp "unzip -lv" "$2"
-#endif
-#ifdef unrar
-  elif [[ "$1" = *RAR\ archive* ]]; then
+  elif [[ -n $(type -P unrar) ]] && [[ "$1" = *RAR\ archive* ]]; then
     echo "==> use rar_file${sep}contained_file to view a file in the archive"
     istemp "unrar v" "$2"
-#elif rar
-  elif [[ "$1" = *RAR\ archive* ]]; then
+  elif [[ -n $(type -P rar) ]] && [[ "$1" = *RAR\ archive* ]]; then
     echo "==> use rar_file${sep}contained_file to view a file in the archive"
     istemp "rar v" "$2"
-#endif
-#ifdef 7za
-  elif [[ "$1" = *7-zip\ archive* ]]; then
+  elif [[ -n $(type -P 7za) ]] && [[ "$1" = *7-zip\ archive* ]]; then
     typeset res
     res=$(istemp "7za l" "$2")
     if [[ "$res" = *\ 1\ file* ]]; then
@@ -597,47 +552,32 @@
       echo "==> use 7za_file${sep}contained_file to view a file in the archive"
       echo "$res"
     fi
-#endif
-#ifdef cabextract
-  elif [[ "$1" = *[Cc]abinet* ]]; then
+  elif [[ -n $(type -P cabextract) ]] && [[ "$1" = *[Cc]abinet* ]]; then
     echo "==> use cab_file${sep}contained_file to view a file in the cabinet"
     istemp "cabextract -l" "$2"
-#endif
-#ifdef dvi2tty
-  elif [[ "$1" = *\ DVI* ]]; then
+  elif [[ -n $(type -P dvi2tty) ]] && [[ "$1" = *\ DVI* ]]; then
     echo "==> append $sep to filename to view the binary DVI file"
     isdvi "$2"
-#endif 
   elif [[ "$PARSEHTML" = yes && "$1" = *HTML* ]]; then
     echo "==> append $sep to filename to view the HTML source"
     parsehtml "$2"
-#ifdef pdftohtml
-  elif [[ "$PARSEHTML" = yes && "$1" = *PDF* ]]; then
+  elif [[ -n $(type -P pdftohtml) ]] && [[ "$PARSEHTML" = yes && "$1" = *PDF* ]]; then
     echo "==> append $sep to filename to view the PDF source"
     t=$(nexttmp)
     cat "$2" > "$t"; pdftohtml -stdout "$t" | parsehtml -
-#endif
-#ifdef pdftotext
-  elif [[ "$1" = *PDF* ]]; then
+  elif [[ -n $(type -P pdftotext) ]] && [[ "$1" = *PDF* ]]; then
     echo "==> append $sep to filename to view the PDF source"
     istemp pdftotext "$2" -
-#endif
-#ifdef djvutxt
-  elif [[ "$1" = *DjVu* ]]; then
+  elif [[ -n $(type -P djvutxt) ]] && [[ "$1" = *DjVu* ]]; then
     echo "==> append $sep to filename to view the DjVu source"
     djvutxt "$2"
-#endif
-#ifdef antiword
-  elif [[ "$1" = *Microsoft\ Word* || "$1" = *Microsoft\ Office* ]]; then
+  elif [[ -n $(type -P antiword) ]] && [[ "$1" = *Microsoft\ Word* || "$1" = *Microsoft\ Office* ]]; then
     echo "==> append $sep to filename to view the raw word document"
     antiword "$2"
-#elif catdoc
-  elif [[ "$1" = *Microsoft\ Word* || "$1" = *Microsoft\ Office* ]]; then
+  elif [[ -n $(type -P catdoc) ]] && [[ "$1" = *Microsoft\ Word* || "$1" = *Microsoft\ Office* ]]; then
     echo "==> append $sep to filename to view the raw word document"
     catdoc "$2"
-#endif
-#ifdef unrtf
-  elif [[ "$1" = *Rich\ Text\ Format* ]]; then
+  elif [[ -n $(type -P unrtf) ]] && [[ "$1" = *Rich\ Text\ Format* ]]; then
     if [[ "$PARSEHTML" = yes ]]; then
       echo "==> append $sep to filename to view the RTF source"
       istemp "unrtf --html" "$2" | parsehtml -
@@ -645,28 +585,19 @@
       echo "==> append $sep to filename to view the RTF source"
       istemp "unrtf --text" "$2" | sed -e "s/^### .*//" | fmt -s
     fi
-#endif
-#ifdef xlhtml
-  elif [[ "$PARSEHTML" = yes && "$1" = *Excel\ document* ]]; then
+  elif [[ -n $(type -P xlhtml) ]] && [[ "$PARSEHTML" = yes && "$1" = *Excel\ document* ]]; then
     echo "==> append $sep to filename to view the spreadsheet source"
     xlhtml -te "$2" | parsehtml -
-#endif 
-#ifdef ppthtml
-  elif [[ "$PARSEHTML" = yes && "$1" = *PowerPoint\ document* ]]; then
+  elif [[ -n $(type -P ppthtml) ]] && [[ "$PARSEHTML" = yes && "$1" = *PowerPoint\ document* ]]; then
     echo "==> append $sep to filename to view the PowerPoint source"
     ppthtml "$2" | parsehtml -
-#endif
-#ifdef o3tohtml,unzip
-  elif [[ "$PARSEHTML" = yes && ("$1" = *OpenDocument\ [CHMPST]* || "$1" = *OpenOffice\.org\ 1\.x\ [CIWdgpst]*) ]]; then
+  elif [[ -n $(type -P o3tohtml) && -n $(type -P unzip) ]] && [[ "$PARSEHTML" = yes && ("$1" = *OpenDocument\ [CHMPST]* || "$1" = *OpenOffice\.org\ 1\.x\ [CIWdgpst]*) ]]; then
     echo "==> append $sep to filename to view the OpenOffice or OpenDocument source"
     istemp "unzip -avp" "$2" content.xml | o3tohtml | parsehtml -
-#elif unzip
-  elif [[ "$1" = *OpenDocument\ [CHMPST]* || "$1" = *OpenOffice\.org\ 1\.x\ [CIWdgpst]* ]]; then
+  elif [[ -n $(type -P unzip) ]] && [[ "$1" = *OpenDocument\ [CHMPST]* || "$1" = *OpenOffice\.org\ 1\.x\ [CIWdgpst]* ]]; then
     echo "==> append $sep to filename to view the OpenOffice or OpenDocument source"
     istemp sxw2txt "$2"
-#endif
-#ifdef isoinfo
-  elif [[ "$1" = *ISO\ 9660* ]]; then
+  elif [[ -n $(type -P isoinfo) ]] && [[ "$1" = *ISO\ 9660* ]]; then
     if [[ "$2" != - ]]; then
       echo "==> append $sep to filename to view the binary data"
       isoinfo -d -i "$2"
@@ -674,60 +605,46 @@
       echo "================================= Content ======================================"
       isoinfo -lR$joliet -i "$2"
     fi
-#endif 
-#ifdef identify
-  elif [[ "$1" = *image\ data*  || "$1" = *image\ text* || "$1" = *JPEG\ file* || "$1" = *JPG\ file* ]]; then
+  elif [[ -n $(type -P identify) ]] && [[ "$1" = *image\ data*  || "$1" = *image\ text* || "$1" = *JPEG\ file* || "$1" = *JPG\ file* ]]; then
     echo "==> append $sep to filename to view the binary data"
     identify -verbose "$2"
-#endif 
-#ifdef id3v2
-  elif [[ "$1" = *MPEG\ *layer\ 3\ audio* || "$1" = *MPEG\ *layer\ III* || "$1" = *mp3\ file* || "$1" = *MP3* ]]; then
+  elif [[ -n $(type -P id3v3) ]] && [[ "$1" = *MPEG\ *layer\ 3\ audio* || "$1" = *MPEG\ *layer\ III* || "$1" = *mp3\ file* || "$1" = *MP3* ]]; then
     echo "==> append $sep to filename to view the binary data"
     istemp "id3v2 -l" "$2"
-#elif mp3info
-  elif [[ "$1" = *MPEG\ *layer\ 3\ audio* || "$1" = *MPEG\ *layer\ III* || "$1" = *mp3\ file* || "$1" = *MP3* ]]; then
+  elif [[ -n $(type -P mp3info) ]] && [[ "$1" = *MPEG\ *layer\ 3\ audio* || "$1" = *MPEG\ *layer\ III* || "$1" = *mp3\ file* || "$1" = *MP3* ]]; then
     echo "==> append $sep to filename to view the binary data"
     mp3info "$2"
-#endif
-#ifdef lsbom
+  elif [[ -n $(type -P lsbom) ]] && [[ "$1" = *bill\ of\ materials* ]]; then
     echo "==> append $sep to filename to view the binary data"
-  elif [[ "$1" = *bill\ of\ materials* ]]; then
     lsbom -p MUGsf "$2"
-#endif
   elif [[ "$1" = *perl\ Storable* ]]; then
     echo "==> append $sep to filename to view the binary data"
     perl -MStorable=retrieve -MData::Dumper -e '$Data::Dumper::Indent=1;print Dumper retrieve shift' "$2"
-#ifdef iconv
-  elif [[ "$1" = *UTF-8* && $LANG != *UTF*8* && $LANG != *utf*8* ]]; then
+  elif [[ -n $(type -P iconv) ]] && [[ "$1" = *UTF-8* && $LANG != *UTF*8* && $LANG != *utf*8* ]]; then
     echo "==> append $sep to filename to view the UTF-8 encoded data"
     iconv -f UTF-8 -t ISO-8859-1 "$2"
-  elif [[ "$1" = *ISO-8859* && ($LANG = *UTF*8* || $LANG = *utf*8*) ]]; then
+  elif [[ -n $(type -P iconv) ]] && [[ "$1" = *ISO-8859* && ($LANG = *UTF*8* || $LANG = *utf*8*) ]]; then
     echo "==> append $sep to filename to view the ISO-8859 encoded data"
     iconv -f ISO-8859-1 -t UTF-8 "$2"
-  elif [[ "$1" = *UTF-16* && $LANG != *UTF*8* && $LANG != *utf*8* ]]; then
+  elif [[ -n $(type -P iconv) ]] && [[ "$1" = *UTF-16* && $LANG != *UTF*8* && $LANG != *utf*8* ]]; then
     echo "==> append $sep to filename to view the UTF-16 encoded data"
     iconv -f UTF-16 -t ISO-8859-1 "$2"
-  elif [[ "$1" = *UTF-16* && ($LANG = *UTF*8* || $LANG = *utf*8*) ]]; then
+  elif [[ -n $(type -P iconv) ]] && [[ "$1" = *UTF-16* && ($LANG = *UTF*8* || $LANG = *utf*8*) ]]; then
     echo "==> append $sep to filename to view the UTF-16 encoded data"
     iconv -f UTF-16 -t UTF-8 "$2"
-#endif
-#ifdef gpg
-  elif [[ "$1" = *GPG\ encrypted\ data* ]]; then
+  elif [[ -n $(type -P gpg) ]] && [[ "$1" = *GPG\ encrypted\ data* ]]; then
     echo "==> append $sep to filename to view the encrypted file"
     gpg -d "$2"
-#endif
-#ifdef plutil
-  elif [[ "$1" = *Apple\ binary\ property\ list* ]]; then
+  elif [[ -n $(type -P plutil) ]] && [[ "$1" = *Apple\ binary\ property\ list* ]]; then
     echo "==> append $sep to filename to view the binary data"
     plutil -convert xml1 -o - "$2"
-#endif
   elif [[ "$1" = *data* ]]; then
     echo "==> append $sep to filename to view the $1 source"
     nodash strings "$2"
   else
     set "plain text" "$2"
   fi
-#ifdef perl
+  if [[ -n $(type -P perl) ]]; then
   if [[ "$1" = *plain\ text* ]]; then
     dir=${LESSOPEN#\|}
     dir=${dir%%lesspipe.sh*\%s}
@@ -736,7 +653,7 @@
       return
     fi
   fi
-#endif
+  fi
   if [[ "$2" = - ]]; then
     cat
   fi  
